/* ***************************************************************************
Original Filename:   algebra.pc
Current Filename:    alg.pc
Revision Date:       Not Specified
Author:              Jaret Funk
Student#:            194-6-02491
Course:              CS 470-001
Date:                19 April 1999

Maintenance:
//First Set
Maintainer: Haibo Wang
Student#:   Not Specified
Course:     Not Specified
Date:       28 January 2004

//Second Set
Maintainer: Mathieu Leblanc
Student#:   101092676
Course:     COMP4905A
Date:       23 April 2021

Purpose:
  Contains functions that translate the relational algebra statement into sql 
  if needed, execute this sql, and display the results to the screen if so 
  desired.
****************************************************************************** */
#include "alg.h"
#include <setjmp.h>

//Maximum number of select-list items or bind variables.
#define MAX_ITEMS 40

/*
  Maximum lengths of the _names_ of the select-list items or indicator 
  variables. 
*/

//Define the maximum length of field.
#define MAX_VNAME_LEN 30

//Define the maximum length of an indicator variables.
#define MAX_INAME_LEN 30

#ifndef NULL
#define NULL  0
#endif

//Possible sql dml commands that could be executed.
char* dml_commands[] = {"SELECT", "select", "INSERT", "insert",
                        "UPDATE", "update", "DELETE", "delete"}; 
		
//Declare an array that will contain the sql statements to be executed.
exec sql begin declare section;
char sql_statement[1024];
exec sql var sql_statement is string(1024);
exec sql end declare section;
 
//Include SQL Communications Area, and SQL Descriptor Area.
exec sql include sqlca;
exec sql include sqlda;

//Pointers to SQLDA structures.
//SQLDA structure for bind variables.
SQLDA* bind_dp;
//SQLDA structure for query result.
SQLDA* select_dp;

//Declare external structures and functions.
extern SQLDA* sqlald();
extern void sqlnul();

//File pointers to be used for input and output to the interpreter.
extern FILE* yyin;
extern FILE* yyout;

//Define a buffer to hold longjmp state info.
jmp_buf jmp_continue;

/*
  A global flag for the error routine to indicate if parsing information 
  should be included in the error messages.
*/
int  parse_flag = 0;
//Global flag to indicate if an oracle error was raised.
char f_oracle_error = 'F';
//Global pointer to list of temporary tables that must be dropped.
LIST *temp_table_list = NULL;
//Global pointer to list of renamed tables that must be dropped.
LIST *ren_table_list = NULL;

/*
  Global flag to indicate if a join operation was conducted for the current 
  ALG statement.
*/
int join_flag = 0;

/*----------------------------------------------------------------------------
Function name:
  executesqlstmt 
Purpose:
  To execute a sql statement and display or return the results if so desired.

Parameters:
  sqlstmt           The statement to be executed.
	f_display	        Flag that signals the results	to be displayed if equal to 
                    Y	else the results are returned	in a linked list. 
  create_flag       To print message for creating temp table (1 for print 
                    message).
Returns:
	A Linked list of type LIST that will contain results of query if 
  f_display = 'N', otherwise it is NULL.
------------------------------------------------------------------------------ */

LIST* executesqlstmt(char* sqlstmt, char f_display, int create_flag)
{
  if(debug_mode) printf("\n\nIn executesqlstmt(): The sql statement is :\n\n%s\n\n", sqlstmt);

  /*
    Integer variable used to iterate through a list of dml commands to 
    determine if the sql statement was executed, and to find the number 
    of rows in the search result from the last query.
  */
  int i;
  
  /*
    Integer variable used to iterate through the array used to hold an 
    sql_statement in order to reset each of the characters in that array to
    null terminators.
  */
  int j;
  
  //Pointer to list containing all of the column names from the query result.
  LIST* columns = NULL;
  
  //Save current location to return to if sql error occurs.
  i = setjmp(jmp_continue); 

  //Execute the following code only if a sql error did not occur.
  if (f_oracle_error == 'F')
  {
    //Reset sql_statement array.
    for(j=0; j<MAXSTMTLENGTH; j++){
      sql_statement[j]='\0';
    }
    strncpy(sql_statement, sqlstmt, MAXSTMTLENGTH);

    /* Prepare the statement and declare a cursor. */
    exec sql whenever sqlerror do sql_error();

    /* 
      Set a flag for sql_error() indicating that we would like to have the 
      error location in the sql statement should an error arise.
    */
    parse_flag = 1;     
    exec sql prepare s from :sql_statement;
    //Unset the flag.
    parse_flag = 0;     

    exec sql declare c cursor for s;

    //Set the bind variables for any placeholders in the SQL statement.
    set_bind_variables();

    /*
      Open the cursor and execute the statement.
      If the statement is not a query (SELECT), the statement processing 
      is completed after the OPEN.
    */

    exec sql open c using descriptor bind_dp;

    if (f_display == 'Y')
    {
      /* 
        Call the function that processes the select-list.
        If the statement is not a query, this function just returns, 
        doing nothing.
      */
        
      process_select_list();

      /*
        If the flag indicating that a table was created is set to 1, 
        then print a message.
      */
      if(create_flag == 1)
      {
        fprintf(yyout, "\nTable created.\n");
      }

      /* Tell user how many rows processed. */
      for (i = 0; i < 8; i++)
      {
      	if (strncmp(sql_statement, dml_commands[i], 6) == 0)
      	{
          fprintf(yyout, "\n%d row%c processed.\n\n", sqlca.sqlerrd[2],
          sqlca.sqlerrd[2] == 1 ? ' ' : 's');
          break;
        }
      }
    }
    else
    {
      //Retrieve column names from query.
      columns = retrieve_columns();
    }
  }
  else
  {
    /*
      If an error occurred, reflect that with replacing the sql statement 
      with an error.
    */
    strcpy(sqlstmt, "0000000ERROR_OCCURED0000000");
    f_oracle_error = 'F';
  }
  //Return list of columns from query.
  return columns;
}


/*----------------------------------------------------------------------------
Function name:
  retrieve_columns 
Purpose:
  To place the retrieved column names into a linked list and return the list.

Parameters:
  None.

Returns:
	A Linked list containing the retrieved column names.
------------------------------------------------------------------------------ */
LIST* retrieve_columns()
{
  if(debug_mode) printf("\nIn retrieve_columns(). ");

  //Integer variable to indicate whether values can be NOT NULL.
	int null_ok;
  
  //Pointer to list storing column names, with a null terminator appended.
  LIST* columns = NULL;

	/*
    If the SQL statement is a SELECT, describe the select-list items.
    The DESCRIBE function returns their names, datatypes, lengths (including 
    precision and scale), and NULL/NOT NULL statuses.
  */

	select_dp->N = MAX_ITEMS;
	    
	exec sql describe select list for s into select_dp;
	
	/*
    If F is negative, there were more select-list items than originally 
    allocated by sqlald().
  */
	if (select_dp->F < 0)
	{
		fprintf (yyout, "\nToo many select-list items (%d), maximum is %d\n",
	                -(select_dp->F), MAX_ITEMS);
    return;
	}
	
	/* 
    Set the maximum number of array elements in the descriptor to the 
    number found.
  */
	select_dp->N = select_dp->F;
	
	    
	/*
    Turn off high-order bit of datatype (in this example, it does not matter 
    if the column is NOT NULL).
  */
	sqlnul (&(select_dp->T[0]), &(select_dp->T[0]), &null_ok);
	
	/*
    Allocate space for the select-list data values.
    sqlald() reserves a pointer location for V[i] but does not allocate the 
    full space for the pointer.
  */
  select_dp->V[0] = (char *) realloc(select_dp->V[0], select_dp->L[0] + 1);

	//Coerce ALL datatypes except for LONG RAW and NUMBER to character.
  select_dp->T[0] = 1;
	
	//FETCH each row selected add the column values to the linked list.
  exec sql whenever not found goto end_select_loop;

  for (;;)
  {
    exec sql fetch c using descriptor select_dp;

		//Append null to the end of the string and add the string to the linked list.
		*( select_dp->V[0] + select_dp->L[0])= '\0';
		columns = addtoback(select_dp->V[0], columns, 'I');
  }
  
  end_select_loop:
    //Testing block.
    /*
          int j;
          j = 0;
          j = strlen(select_dp->S[0]);
          printf("\nTesting S[i]: %d, %s\n", j, select_dp->S[0]);
          j = strlen(select_dp->V[0]);
          printf("\nTesting V[i]: %d, %s\n", j, select_dp->V[0]);
    */
    //Return the list of column names.
    return columns;
}

/*----------------------------------------------------------------------------
Function name:
  oracle_disconnect 
Purpose:
  To disconnect from Oracle.

Parameters:
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
void oracle_disconnect()
{
  /*
    Integer variable used to iterate through SQLDA structures and free the 
    memory allocated for those structures.
  */
  int i;

  /*
    When done, free the memory allocated for pointers in the bind and select 
    descriptors.
  */
  for (i = 0; i < MAX_ITEMS; i++)
  {
    if(bind_dp->V[i] != (char *) 0)
    {
      free(bind_dp->V[i]);
    }
    free(bind_dp->I[i]);
    if(select_dp->V[i] != (char *) 0)
    {
      free(select_dp->V[i]);
    }
    free(select_dp->I[i]); 
  }

  /* Free space used by the descriptors themselves. */
  sqlclu(bind_dp);
  sqlclu(select_dp);

  exec sql whenever sqlerror continue;
  /* Close the cursor. */
  exec sql close c;

  exec sql commit work release;

  fprintf(yyout, "\nHave a good day!\n");


  exec sql whenever sqlerror do sql_error();

  return;
}

/*----------------------------------------------------------------------------
Function name:
  oracle_connect 
Purpose:
  To connect to Oracle.

Parameters:
  None.

Returns:
  0       If connects to Oracle successfully.
	-1      If connection attempt was unsuccessful.
------------------------------------------------------------------------------ */
int oracle_connect(char * p_userid, char * p_passwd)
{
  if(debug_mode) printf("\n(). ");

  //Array used to store the user account information to connect to Oracle.
  EXEC SQL BEGIN DECLARE SECTION;
  char  myid[120];
  EXEC SQL END DECLARE SECTION;

  //Construct login credentials to connect to Oracle.                 
  strcpy(myid, p_userid);
  strcat(myid, "/");
  strcat(myid, p_passwd);
    
  exec sql whenever sqlerror goto connect_error;

  //Attempt to connect using login credentials provided by user.
  exec sql connect :myid;
 
  printf("\nConnected to ORACLE\n");

  //Allocate memory for the select and bind descriptors.
  if (alloc_descriptors(MAX_ITEMS, MAX_VNAME_LEN, MAX_INAME_LEN) != 0)
  {
    exit(1);
  }
  
  return 0;

  //If any error was raised during the login attempt, throw error.
  connect_error:
    fprintf(stderr, "Cannot connect to ORACLE\n");
    return -1;
}

/*----------------------------------------------------------------------------
Function name:
  alloc_descriptors 
Purpose:
  To allocate the BIND and SELECT descriptors using sqlald().
	Also allocate the pointers to indicator variables in each descriptor.
  The pointers to the actual bind variables and the select-list items are 
  realloc'ed in the set_bind_variables() or process_select_list() routines.
  This routine allocates 1 byte for select_dp->V[i] and bind_dp->V[i], so the 
  realloc will work correctly.

Parameters:
  None.

Returns:
  0	      If the operation was successful.
  -1	    If the operation was unsuccessful.
------------------------------------------------------------------------------ */
alloc_descriptors(int size, int max_vname_len, int max_iname_len)
{
  if(debug_mode) printf("\nIn alloc_descriptors(). ");

  /*
    Integer variable used to iterate through the pointers for indicator 
    variables, allocating the memory for each of them.
  */
  int i;

  /*
    The first sqlald parameter determines the maximum number of array 
    elements in each variable in the descriptor. In other words, it 
    determines the maximum number of bind variables or select-list items in 
    the SQL statement.

    The second parameter determines the maximum length of strings used to 
    hold the names of select-list items or placeholders.  The maximum 
    length of column names in ORACLE is 30, but you can allocate more or 
    less as needed.

    The third parameter determines the maximum length of strings used to hold
    the names of any indicator variables. To follow ORACLE standards, the 
    maximum length of these should be 30. But, you can allocate more or less 
    as needed.
  */
  if((bind_dp = sqlald(size, max_vname_len, max_iname_len)) == (SQLDA *) 0)
  {
    fprintf(stderr, "Cannot allocate memory for bind descriptor.");
    /* Have to exit in this case. */
    return -1;
  }

  //Attempt to allocate memory for SQLDA.
  if((select_dp = sqlald (size, max_vname_len, max_iname_len)) == (SQLDA *) 0)
  {
    fprintf(stderr, "Cannot allocate memory for select descriptor.");
    return -1;
  }
    select_dp->N = MAX_ITEMS;

  //Allocate the pointers to the indicator variables, and the actual data.
  for (i = 0; i < MAX_ITEMS; i++) {
    bind_dp->I[i] = (short *) malloc(sizeof (short));
    select_dp->I[i] = (short *) malloc(sizeof(short));
    bind_dp->V[i] = (char *) malloc(1);
    select_dp->V[i] = (char *) malloc(1);
  }
  
  //     
  return 0;
}

/*----------------------------------------------------------------------------
Function name:
  set_bind_variables 
Purpose:
  To realloc the pointers to the actual bind variables and the select-list 
  items.

Parameters:
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
void set_bind_variables()
{
  if(debug_mode) printf("\nIn set_bind_variables(). ");

  //Integer variable used to iterate through bind variables.
  int i;
  
  //Integer variable used to store the length of bind variables.
  int n;
  
  //Array used to store input for bind variables.
  char bindVar[64];

  // Describe any bind variables (input host variables).
  exec sql whenever sqlerror do sql_error();
 
  // Initialize count of array elements.
  bind_dp->N = MAX_ITEMS;  

  exec sql describe bind variables for s into bind_dp;
    
  /* 
    If F is negative, there were more bind variables than originally 
    allocated by sqlald().
  */
  if(bind_dp->F < 0)
  {
    fprintf (yyout, "\nToo many bind variables (%d), maximum is %d\n.",
      -bind_dp->F, MAX_ITEMS);
    return;
  }

  /* 
    Set the maximum number of array elements in the
    descriptor to the number found. 
  */
  bind_dp->N = bind_dp->F;
 
  
  /* 
    Get the value of each bind variable as a character string.
    
    C[i] contains the length of the bind variable name used in the 
    SQL statement.

    S[i] contains the actual name of the bind variable used in the 
    SQL statement.

    L[i] will contain the length of the data value entered.
    
    V[i] will contain the address of the data value entered.
    
    T[i] is always set to 1 because in this sample program data values for all 
    bind variables are entered as character strings.
    ORACLE converts to the table value from CHAR.

    I[i] will point to the indicator value, which is set to -1 when the bind 
    variable value is "null".
  */
  for(i = 0; i < bind_dp->F; i++)
  {
    fprintf(yyout, "\nEnter value for bind variable %.*s:  ",
      (int)bind_dp->C[i], bind_dp->S[i]);
    fgets(bindVar, sizeof bindVar, stdin);

    /* Get length and remove the new line character. */
    n = strlen(bindVar) - 1;

    /* Set it in the descriptor. */
    bind_dp->L[i] = n;
    
    /* 
      (re-)allocate the buffer for the value.
      sqlald() reserves a pointer location for V[i] but does not allocate 
      the full space for the pointer.
    */
    bind_dp->V[i] = (char *) realloc(bind_dp->V[i], (bind_dp->L[i] + 1));

    /* And copy it in. */
    strncpy(bind_dp->V[i], bindVar, n);

    /* Set the indicator variable's value. */
    if ((strncmp(bind_dp->V[i], "NULL", 4) == 0) ||
        (strncmp(bind_dp->V[i], "null", 4) == 0))
    {
      *bind_dp->I[i] = -1;
    }
    else
    {
      *bind_dp->I[i] = 0;
    }
    
    /* Set the bind datatype to 1 for CHAR. */
    bind_dp->T[i] = 1;
  }
}

/*----------------------------------------------------------------------------
Function name:
  process_select_list 
Purpose:
  To realloc the pointers to the actual bind variables and the select-list 
  items and display the results of the query to yyout.

Parameters:
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
process_select_list()
{
  if(debug_mode) printf("\nIn process_select_list(). ");

  /*
    Integer value used to iterate through the headers, or the elements of a 
    results row.
  */
  int i;

  //Used to store whether NOT NULL is admissible.
  int null_ok;
  
  //Used to store precision of data types.
  int precision;
  
  //Used to store scale of data types.
  int scale;
  
  //Used to store the length of the entire row of headers.
  int header_row_length = 0;
  
  /*
    Used to iterate through the characters of a field or header in order to 
    reset their value to null terminators.
  */
  int j;
  
  /*
    Used to iterate through the characters of a field or header in order to
    set their value and blank spaces to resolve formatting issues that existed
    in the program.
  */
  int k;
  
  //If the statement does not begin with select, set the number of fields to 0.
  if((strncmp(sql_statement, "SELECT", 6) != 0) &&
     (strncmp(sql_statement, "select", 6) != 0))
  {
    select_dp->F = 0;
    return;
  }

  
  //Set maximum number of columns
  select_dp->N = MAX_ITEMS;

  /*
    If the SQL statement is a SELECT, describe the select-list items.  
    The DESCRIBE function returns their names, datatypes, lengths 
    (including precision and scale), and NULL/NOT NULL statuses.
  */
  exec sql describe select list for s into select_dp;

  /*
    If F is negative, there were more select-list
    items than originally allocated by sqlald(). 
  */
  if (select_dp->F < 0)
  {
    fprintf (yyout, "Too many select-list items (%d), maximum is %d\n",
      -(select_dp->F), MAX_ITEMS);
    return;
  }

  /*
    Set the maximum number of array elements in the descriptor to the 
    number found.
  */
  select_dp->N = select_dp->F;
  
  /*
    Allocate storage for each select-list item. sqlprc() is used to extract 
    precision and scale from the length (select_dp->L[i]).

    sqlnul() is used to reset the high-order bit of the datatype and to 
    check whether the column is NOT NULL.

    CHAR      datatypes have length, but zero precision and scale. 
              The length is defined at CREATE time.

    NUMBER    datatypes have precision and scale only if defined at CREATE 
              time. If the column definition was just NUMBER, the precision 
              and scale are zero, and you must allocate the required maximum 
              length.

    DATE      datatypes return a length of 7 if the default format is used. 
              This should be increased to 9 to store the actual date 
              character string. If you use the TO_CHAR function, the maximum 
              length could be 75, but will probably be less (you can see the 
              effects of this in SQL*Plus).

    ROWID     datatype always returns a fixed length of 18 if coerced to CHAR.

    LONG and
    LONG RAW  datatypes return a length of 0 (zero), so you need to set a 
              maximum. In this example, it is 240 characters.
  */
  fprintf (yyout, "\n");
  for (i = 0; i < select_dp->F; i++)
  {
    /*
      Array used to temporarily store the formatted value of the current 
      header element.
    */
    char tempHeader[MAX_VNAME_LEN];
    
    /*  
      Turn off high-order bit of datatype (in this example, it does not 
      matter if the column is NOT NULL).
    */
    sqlnul (&(select_dp->T[i]), &(select_dp->T[i]), &null_ok);
    
    /*
      Conditional block for the type of each column.
      Set the size of the data type used for the column.
    */
    switch (select_dp->T[i])
    {
      /*  
        CHAR datatype: no change in length
        needed, except possibly for TO_CHAR
        conversions (not handled here).
      */
      case  1: 
        break;
      
      /*
        NUMBER datatype: use sqlprc() to extract precision and scale.
      */
      case  2: 
        sqlprc (&(select_dp->L[i]), &precision, &scale);              
        /* Allow for maximum size of NUMBER. */
        if (precision == 0) precision = 40;

        /* Also allow for decimal point and possible sign. */
        /* convert NUMBER datatype to FLOAT if scale > 0, INT otherwise. */
        if (scale > 0)
        {
          select_dp->L[i] = sizeof(float);
        }
        else
        {
          select_dp->L[i] = sizeof(int);
        }
        break;

      /* LONG datatype */
      case  8:
        select_dp->L[i] = 240;
        break;

      /* ROWID datatype */
      case 11:
        select_dp->L[i] = 18;
        break;

      /* DATE datatype */
      case 12: 
        select_dp->L[i] = 9;
        break;

      /* RAW datatype */
      case 23:
        break;

      /* LONG RAW datatype */
      case 24:
        select_dp->L[i] = 240;
        break;
    }
    
    /* 
      Allocate space for the select-list data values. sqlald() reserves a 
      pointer location for V[i] but does not allocate the full space for 
      the pointer.
    */
    if (select_dp->T[i] != 2)
    {
      select_dp->V[i] = (char *) realloc(select_dp->V[i], select_dp->L[i] + 1);
    }
    else
    {
      select_dp->V[i] = (char *) realloc(select_dp->V[i], select_dp->L[i]);
    }
    
    /*
      Print column headings, right-justifying number
      column headings.
    */
    header_row_length = strlen(select_dp->S[0]);
    if (select_dp->T[i] == 2)
    {
      if (scale > 0)
      {
        for(k = 0; k < MAX_VNAME_LEN-1; k++)
        {
          if(select_dp->S[i][k]=='\0')
          {
            break;
          }
          else if(select_dp->S[i][k]==' ')
          { 
            //If last element of the field, break from loop.
            if(k==MAX_VNAME_LEN-2 || select_dp->S[i][k+1]==' ' || select_dp->S[i][k]=='\0')
            {
              break;
            }
          }
          //Assign current tempHeader character the value stored in the result at the same index.
          tempHeader[k] = select_dp->S[i][k];
        }
        //Add spaces to fix spacing issues.
        for(; k < MAX_VNAME_LEN-1 && k < (select_dp->L[i]+3); k++){
          tempHeader[k] = ' ';
        }
        //Terminate field.
        tempHeader[k] = '\0';
        //Print field.
        fprintf (yyout, "%.*s ", select_dp->L[i]+3, tempHeader);
      }
      else
      {
        for(k = 0; k < MAX_VNAME_LEN-1; k++)
        {
          if(select_dp->S[i][k]=='\0')
          {
            break;
          }
          else if(select_dp->S[i][k]==' ')
          {
            //If last element of the field, break from loop.
            if(k==MAX_VNAME_LEN-2 || select_dp->S[i][k+1]==' ' || select_dp->S[i][k]=='\0')
            {
              break;
            }
          }
          //Assign current tempHeader character the value stored in the result at the same index.
          tempHeader[k] = select_dp->S[i][k];
        }
        //Add spaces to fix spacing issues.
        for(; k < MAX_VNAME_LEN-1 && k < (select_dp->L[i]); k++){
          tempHeader[k] = ' ';
        }
        //Terminate field.
        tempHeader[k] = '\0';
        //Print field.
        fprintf (yyout, "%.*s ", select_dp->L[i], tempHeader);
      }
    }
    else
    {
      for(k = 0; k < MAX_VNAME_LEN-1; k++)
      {
        if(select_dp->S[i][k]=='\0')
        {
          break;
        }
        else if(select_dp->S[i][k]==' ')
        {
          //If last element of the field, break from loop.
          if(k==MAX_VNAME_LEN-2 || select_dp->S[i][k+1]==' ' || select_dp->S[i][k]=='\0')
          {
            break;
          }
        }
        //Assign current tempHeader character the value stored in the result at the same index.
        tempHeader[k] = select_dp->S[i][k];
      }
              //Add spaces to fix spacing issues.
      for(; k < MAX_VNAME_LEN-1 && k < (select_dp->L[i]); k++){
        tempHeader[k] = ' ';
      }
      //Terminate field.
      tempHeader[k] = '\0';
      //Print field.
      fprintf (yyout, "%-.*s ", select_dp->L[i], tempHeader);
    }
    
    /* Coerce ALL datatypes except for LONG RAW and NUMBER to character. */
    if (select_dp->T[i] != 24 && select_dp->T[i] != 2)
    {
	    select_dp->T[i] = 1;
    }
    
    /* Coerce the datatypes of NUMBERs to float or int depending on the scale. */
    if (select_dp->T[i] == 2)
    {
      if (scale > 0)
      {
        select_dp->T[i] = 4;  /* float */
      }
      else
      {
        select_dp->T[i] = 3;  /* int */
      }
    }
  }

  //Reset header entries after printing them.
  fprintf (yyout, "\n");
  for(j=0; j<header_row_length; j++)
  {
    select_dp->S[0][j]='\0';
  }
  
  /* FETCH each row selected and print the column values. */
  exec sql whenever not found goto end_select_loop;

  for (;;)
  {
    exec sql fetch c using descriptor select_dp;

    /*
      Since each variable returned has been coerced to a character string, 
      int, or float very little processing is required here.  This routine 
      just prints out the values on the terminal.
    */
    for (i = 0; i < select_dp->F; i++)
    {
      char tempEntry[MAX_VNAME_LEN];

      if (*select_dp->I[i] < 0)
      {
        /*
          Integer variable used to hold the amount of spaces that need to be written to retain proper formatting of the query results.
        */
        int space = 0;
        //If float, consider floating points.
        if (select_dp->T[i] == 4)
        {
          if(select_dp->L[i]+3 < MAX_VNAME_LEN)
          {
            space = select_dp->L[i]+3;
          }
          else
          {
            space = MAX_VNAME_LEN-1;
          }

          //Print spaces.
          fprintf (yyout, "%-*c ", space, ' ');
        }
        else
        {
          if(select_dp->L[i] < MAX_VNAME_LEN)
          {
            space = select_dp->L[i];
          }
          else
          {
            space = MAX_VNAME_LEN-1;
          }
          //Print spaces
          fprintf (yyout, "%-*c ", space, ' ');
        }
        //Reset the field value within SQLDA.
        for(j=0;j<space+1;j++){
          select_dp->V[i][j] = '\0';
        }
      }
      else
      {
        //Print numbers.
        if (select_dp->T[i] == 3)     /* int datatype */
        {
          fprintf (yyout, "%*d ", (int)select_dp->L[i], *(int *)select_dp->V[i]);
        }
        else if (select_dp->T[i] == 4)     /* float datatype */
        {
          fprintf (yyout, "%*.2f ", (int)select_dp->L[i], *(float *)select_dp->V[i]);
        }
        //Print strings.
        else                          /* character string */
	    	{ 
          //While the index is smaller than maximum length of the field -1, and while
          //the index is smaller than the maximum length of all value fields.
          for(k = 0; k < MAX_VNAME_LEN-1 && k < select_dp->L[i]; k++)
          {
            if(select_dp->V[i][k]=='\0')
            {
              break;
            }
            else if(select_dp->V[i][k]==' ')
            {
              //break after end of field.
              if(k==MAX_VNAME_LEN-2 || k==select_dp->L[i]-1 || select_dp->V[i][k+1]==' ' || select_dp->V[i][k]=='\0')
              {
                break;
              }
            }
            /*
              Assign value of formatted string to the value of select_dp at 
              the same indices.
            */
            tempEntry[k] = select_dp->V[i][k];
          }
          //Add spaces after field values for formatting.
          for(; k < MAX_VNAME_LEN-1 && k < (select_dp->L[i]); k++){
            tempEntry[k] = ' ';
          }
          //Terminate field.
          tempEntry[k] = '\0';

		      /*Add end of string char to the string. */
          fprintf (yyout, "%-*s ", strlen(tempEntry), tempEntry);
        }
      }
    }
	  fprintf (yyout, "\n");
  }

  //Whenever results cannot be found, the program will jump here, and return.
  end_select_loop:
    return;
}

//Updated

/*----------------------------------------------------------------------------
Function name:
  sql_error 
Purpose:
  To handle any sql errors that arise from executing the sql statement.

Parameters:
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
sql_error()
{
  if(debug_mode) printf("\nIn sql_error(). ");

  //Set flag to indicate an sql error occured.
  f_oracle_error = 'T';

  //ORACLE error handler.
  fprintf (yyout, "\n\n%.70s\n",sqlca.sqlerrm.sqlerrmc);

  //Provide parsed error if available.
  if(parse_flag)
  {
    fprintf(yyout, "Parse error at character offset %d in SQL statement.\n", 
      sqlca.sqlerrd[4]);
  }
  
  exec sql whenever sqlerror continue;
  exec sql rollback work;

  //Go back to start of executesqlstmt function.
  longjmp(jmp_continue, 1);
}



/*----------------------------------------------------------------------------
Function name:
  selectStmt 
Purpose:
  To translate a relational algebra select statement into it's corresponding 
  sql statement.

Parameters:
  newconditions     Structure containing the conditions of the select 
                    statement.
	subexpr           Structure containing the sql statement that represents 
                    the subexpression of the select statement.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* selectStmt(SELECTSTMT* newconditions, SELECTSTMT* subexpr)
{
  if(debug_mode) printf("\nIn selectStmt(). ");
  
  //Pointer used for the new statement containing the select statement.
  SELECTSTMT* nselect = NULL;

  //Allocate memory to structure for new select statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }
        

  /*
    Only translate the statement if the subexpression does not contain 
    an error.
  */
  if (subexpr->f_error != 'E')
  { 
    /*
      Set the attributes and tables of the new statement to the ones of 
      the subexpression.
    */
    nselect->attributes = subexpr->attributes;
    nselect->tables = subexpr->tables;
      
    /* Add the table names to the front of the attributes in the new conditions. */
    if (subexpr->tables->front->next == NULL)
    {
      //If only 1 table is present in the subexpression.
      nselect->f_error = addtablename(subexpr->tables->front->id, newconditions->conditions->front, nselect->errormsg);
    }
    else
    {
      //Else, multiple tables are present in the subexpression.
      nselect->f_error = addptablename(newconditions->conditions->front, subexpr->attributes->front, nselect->errormsg);
    }

    //If an error is present in the statement, throw error and free memory.
    if (nselect->f_error == 'E')
    {
      /*
        If the attributes in the new conditions are not in the subexpression 
        raise an error.
      */
      freeexpr(subexpr);
      freelist(newconditions->conditions);
      nselect->attributes = NULL;
      nselect->tables = NULL;

      strcat(nselect->errormsg, " specified in select statement.");
    }
    else
    {
      //Add the new conditions to the new select statement.
      if (subexpr->conditions != NULL)
      {       
        subexpr->conditions = addtolist(" AND ", subexpr->conditions, 'E');
        nselect->conditions = mergelist(newconditions->conditions, subexpr->conditions);
      }
      else
      {
        nselect->conditions = newconditions->conditions;
      }
      //Assign subexpr groupby portion to nselect.
      nselect->groupby = subexpr->groupby;
    }
  }
  else
  {
    /*
      If the subexpression contained an error pass this error on to the new 
      statement structure instead of translating the select statement.
    */
    strncpy(nselect->errormsg, subexpr->errormsg, MAXERRMSGLENGTH);
    nselect->f_error = subexpr->f_error;
    nselect->tables = subexpr->tables;
  }

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  projectstmt 
Purpose:
  To translate a relational algebra project statement into its corresponding 
  select statement.

Parameters:
  newattributes     The attributes in the project statement.
  subexpr           The subexpression of the project statement.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* projectstmt(SELECTSTMT* newattributes, SELECTSTMT* subexpr)
{
  if(debug_mode) printf("\nIn projectstmt(). ");

  //Pointer used for the new statement that will contain the project operation.
  SELECTSTMT* nselect = NULL;
  
  //Pointer used to iterate through the attributes for the project operation.
  LIST_ITEM* current = NULL;
  
  //Pointer used to iterate through the attributes of the subexpression.
  LIST_ITEM* inner_current = NULL;
  
  /*
    Integer variable used as a flag to indicate whether the current project 
    attribute was found.
  */
  int found = 0;
  
  //Array used to store the parse value of an attribute.
  char temp_str[MAXLENGTH];

  //Allocate memory to new select statement structure.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  /* 
    Only translate the statement if the subexpression does not contain
    an error.
  */
  if(subexpr->f_error != 'E')
  {
    //Testing block.
    /*
            LIST_ITEM* tmp_item = NULL;
            tmp_item = newattributes->attributes->front;
            while (tmp_item != NULL)
            {
              printf("\n In projectstmt():, tmp_item->id is : %s ", tmp_item->id);
              tmp_item = tmp_item->next;
            }
            printf("\n\n");
    */
 
    /* 
      Set the conditions and tables of the new select statement
      to those of the subexpression. 
    */
    nselect->conditions = subexpr->conditions;
    nselect->tables = subexpr->tables;
               
    /* 
      Add the table name to the front of the new attributes in the
      project statement.
    */
    if(subexpr->tables->front->next == NULL)
    {
      //Handle the case where only 1 table is in the subexpression..
      nselect->f_error = addtablename(subexpr->tables->front->id, newattributes->attributes->front, nselect->errormsg);                  
    }
    else
    {
      //Handle the case where multiple tables are in the subexpression.
      current = newattributes->attributes->front;
      while(current != NULL)
      {
        inner_current = subexpr->attributes->front;
        uppercase(current->id);

        //If element is not a comma, try to find it in the subexpression.
        if (strcmp(current->id, ", ") != 0)
        {
          found = 0;
          while(found == 0 && inner_current != NULL)
          {
            if (strcmp(inner_current->id, ", ") != 0)
            {
              parse_attribute(inner_current->id, temp_str);
              //If found, flip flag.
              if(compare_attribute(current->id, temp_str) == 0)
              {
                strcpy(current->id, inner_current->id);
                found = 1;
              }
            }
            inner_current = inner_current->next;
          }

          //If the project attribute was not found, assign error character.
          if (found == 0)
          {
            nselect->f_error = 'E';
          }
        }
        //Iterate to next project attribute.
        current = current->next;
      }
    }

    //If an error is present, throw error and free memory.
    if (nselect->f_error == 'E')
    {
      /* If the new attributes are not in the subexpression
         raise an error. */
      freeexpr(subexpr);
      freelist(newattributes->attributes);
      nselect->conditions = NULL;
      nselect->tables = NULL;

      strcat(nselect->errormsg, " specified in project statement.");
    }
    else
    {
      /*
        Set the attributes of the new select statement to the ones specified 
        in the project statement.
      */
      nselect->attributes = newattributes->attributes;
      nselect->groupby = subexpr->groupby;
      nselect->having = subexpr->having;
      nselect->orderby = subexpr->orderby;
    }
  }
  else
  {
    /*
      If the subexpression contained an error pass this on to the new 
      select statement structure instead of translating the statement.
    */
    strncpy(nselect->errormsg, subexpr->errormsg, MAXERRMSGLENGTH);
    nselect->f_error = subexpr->f_error;
    nselect->tables = subexpr->tables;
  }

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  renameattribute 
Purpose:
  Rename the attributes of the original relation.

Parameters:
  str               Relation name.
  variables         The attributes of the relation.
  expression        The query to be used to build the table.

Returns:
  None.
------------------------------------------------------------------------------ */
void renameattribute(char* str, SELECTSTMT* variables, SELECTSTMT* expression, int need_free_flag, int print_flag)
{
  if(debug_mode) printf("\nIn renameattribute(). ");

  //Array used to hold the formatted table name for the rename operation.
  char table_name[MAXLENGTH];
  
  //Array used to hold all of the attribute values.
  char temp_str[MAXLENGTH];
  
  //Pointer used to iterate through the attributes list.
  LIST_ITEM* current = NULL;

  /*
    If the string holding the table name to be used for the rename operation 
    is empty, generate a randomized table name.
  */
  if(str[0]=='\0')
  {
    int i = 1;
    do
    {
      snprintf(str, MAXLENGTH-1, "RENTAB%d", i);
      str[MAXLENGTH-1]='\0';
      ++i;
    }while(temptable_test(str) != 0);
  }

  /*
    Initialize start of array, initialize pointer, and iterate through 
    the list.
  */
  temp_str[0] = '\0';
  current = variables->attributes->front;
  while(current != NULL)
  {
    strcat(temp_str, current->id);
    current = current->next;
  }
  
  //Create formatted string.
  strcpy(table_name, str);
  strcat(table_name, "(");
  strcat(table_name, temp_str);
  strcat(table_name, ")");

  //Complete rename operation.
  assignQuery(table_name, expression, need_free_flag, print_flag);

  //If an error occurred, copy it to str.
  if(strcmp(table_name, "0000000ERROR_OCCURED0000000") == 0){
    strcpy(str, "0000000ERROR_OCCURED0000000");
  }

  //Free the original expression.
  freeexpr(variables);
}



/*----------------------------------------------------------------------------
Function name:
  addRelation 
Purpose:
  To add table name to the structure of sql statement.

Parameters:
  tablename         A relation name.

Returns:
  The structure of sql statement contain the table name.
------------------------------------------------------------------------------ */
SELECTSTMT* addRelation(char* tablename)
{
  if(debug_mode) printf("\nIn addRelation(). ");

  //Pointer to the new statement for the relation to be added.
  SELECTSTMT* ntable = NULL;

  //Allocate memory to new select statement structure.
  if ((ntable = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to structure!");
    exit(1);
  }

  //Initialize the value of the pointer, and allocate the memory for the list.
  ntable->attributes = NULL;
  if ((ntable->attributes = (LIST*) calloc(1, sizeof(LIST))) == NULL)
	{
		fprintf(stderr, "Not enough memory to allocate to list!");
	  exit(1);
	}

  //Initialize all pointers to NULL.
  ntable->tables = NULL;
  ntable->conditions = NULL;
  ntable->groupby = NULL;
  ntable->having = NULL;
  ntable->orderby = NULL;
  ntable->f_error = 'F';
  ntable->errormsg[0] = '\0';
  ntable->info[0] = '\0';

  /*
    If attributes exist for the table, populate the statement with the 
    attributes and the table.
  */
  if (retrieve_column_names(tablename) != NULL)
  {
    lowercase(tablename);
    ntable->tables = addtolist(tablename, ntable->tables, 'I');
    addattributes(ntable->tables->front->id, ntable);
  }
  //Else, throw error from table not existing.
  else
  {
    ntable->f_error = 'E';
    strncpy(ntable->errormsg, "Table ", MAXERRMSGLENGTH);
    strcat(ntable->errormsg, tablename);
    strcat(ntable->errormsg, " does not exist in database.");	
  }

  //Return new statement.
  return ntable;  
}



/*----------------------------------------------------------------------------
Function name:
  assignQuery 
Purpose:
  To execute a query in the form of a select structure and store the result 
  in a new table.

Parameters:
  table             The name for the temp table.
  need_free_flag    For free structure expression (1 indicate free).
  print_flag        For print message for temp table (1 indicate print message).

Returns:
  None.
------------------------------------------------------------------------------ */
void assignQuery(char* table, SELECTSTMT* expression, int need_free_flag, int print_flag)
{
  if(debug_mode) printf("\nIn assignQuery(). ");
  
  //Array used to hold the new SQL statement for the rename operation.
  char temp_sqlstmt[MAXSTMTLENGTH];
  
  //Array used to hold the SQL statement for the expression.
  char temp_sqlstmt_1[MAXSTMTLENGTH];
  
  //Array used to hold the table name to be used for the rename.
  char temp_table_name[MAXSTMTLENGTH];
  
  /*
    Pointer used to hold the position of the token starting at the first 
    instance of an open bracket.
  */
  char* temp_str = NULL;

 
  //Testing blocks.
  /*
          // T E S T I N G
          //
          //
          LIST_ITEM* current = NULL;
          current = expression->attributes->front;
          while (current != NULL)
          {
            printf("%s\n", current->id);
            current = current->next;
          }
  */
  /*
          LIST_ITEM* tmp_item = NULL; 
          if (find_duplicated_column(expression) == 1 )
          {
            expression->f_error = 'E'; 
            strcpy(expression->errormsg, "ERROR: duplicated column name");
            tmp_item = expression->attributes->front;
            while (tmp_item != NULL)
            {
              printf("\n In assignQuery(): tmp_item->id is : %s , tmp_item->typr is : %c", 
                tmp_item->id, tmp_item->type);
              tmp_item = tmp_item->next;
            }
            printf("\n\n");
          }
  */

  /*
    Get table name without parenthesis.
  */
  strcpy(temp_table_name, table);
  if ((temp_str = strstr(temp_table_name, "(")) != NULL)
  {
    //End table name at the position of the open bracket.
    temp_str[0] = '\0';

    //If the table already exists, throw error.
    if(temptable_test(temp_table_name) == 1)
    {
      expression->f_error = 'E';
      char tempErrorMsg[MAXERRMSGLENGTH];
      snprintf(tempErrorMsg, MAXERRMSGLENGTH-1, "%s %s %s", "A table with name", temp_table_name, "already exists.");
      tempErrorMsg[MAXERRMSGLENGTH-1] = '\0';
      strcpy(expression->errormsg, tempErrorMsg);
    }
  }
  //If the table already exists, throw error.
  else if(temptable_test(temp_table_name) == 1)
  {
    expression->f_error = 'E';
    char tempErrorMsg[MAXERRMSGLENGTH];
    snprintf(tempErrorMsg, MAXERRMSGLENGTH-1, "%s %s %s", "A table with name", temp_table_name, "already exists.");
    tempErrorMsg[MAXERRMSGLENGTH-1] = '\0';
    strcpy(expression->errormsg, tempErrorMsg);
  }
  
  //Testing block.
  /*
          // T E S T I N G
          //
          //
          current = NULL;
          current = expression->attributes->front;
          while (current != NULL)
          {
            printf("%s %c\n", current->id, current->type);
            current = current->next;
          } 
  */
  
  //If the expression contains no error, build statement and execute.
  if(expression->f_error != 'E') 
  { 
    strcpy(temp_sqlstmt, "CREATE TABLE ");
    strcat(temp_sqlstmt, table);
    strcat(temp_sqlstmt, " AS\n");
    
    buildselectstmt(temp_sqlstmt_1, expression);        
    strcat(temp_sqlstmt, temp_sqlstmt_1);
    if(debug_mode) printf("\n\nIn assignQuery():\n\n%s\n\n", temp_sqlstmt);
    executesqlstmt(temp_sqlstmt, 'Y', print_flag);
    if(strcmp(temp_sqlstmt, "0000000ERROR_OCCURED0000000") == 0)
    {
      strcpy(table, "0000000ERROR_OCCURED0000000");
    }
  }
  //If the expression contains an error, reflect that in table name.
  else
  {
    fprintf(yyout, "\n%s\n", expression->errormsg);
    strcpy(table, "0000000ERROR_OCCURED0000000");
  }

  //If it was flagged for freeing, free the expression.
  if(need_free_flag == 1)
  {
    freeexpr(expression);
  }
}



/*----------------------------------------------------------------------------
Function name:
  temptable_test 
Purpose:
  To check if temptable being built is already exist.

Parameters:
  table             The name for the temp table.
 
Returns:
1         Temptable exists.
0         Temptable does not exists.
------------------------------------------------------------------------------ */
int temptable_test(char* tablename)
{
  if(debug_mode) printf("\n In temptable_test(). ");

  //Array used to store the query for the table names of the user tables.
  char newsqlstmt[MAXSTMTLENGTH];
  
  /*
    Array used to store the table name of the current element in the user 
    table list.
  */
  char temp_str[MAXLENGTH];
  
  //Pointer to list of user tables.
  LIST* table_colum = NULL;
  
  //Pointer used to iterate through the user table list.
  LIST_ITEM* current = NULL;
  
  //Integer variable used to store the length of the current element.
  int length;

  //Copy query to array.
  strcpy(newsqlstmt, "select table_name from user_tables");

  //Execute query and store result in list.
  table_colum = executesqlstmt(newsqlstmt, 'N', 0);

  //Testing block.
  /* 
    printList_i(table_colum);
  */

  //Convert the tablename to uppercase.
  uppercase(tablename); 

  //Iterate through the user table list.
  current = table_colum->front;
  while(current != NULL)
  {  
    length = strcspn(current->id, " ");
    strncpy(temp_str, current->id, length);
    temp_str[length] = '\0';
    //If the current table name is the tablename we want to find, return 1.
    if(strcmp(temp_str, tablename) == 0){
      return 1;
    }
    else
    {
      //Iterate.
      current = current->next;
    }
  }

  //Return 0 for not found.
  return 0;
}



/*----------------------------------------------------------------------------
Function name:
  dropTmpTables 
Purpose:
  To avoid have same temp tables, drop the table before it is going to be 
  built later. 

Parameters:
  table             The name for the temp table

Returns:
  None.
------------------------------------------------------------------------------ */
void dropTmpTables(char* tbl_name)
{
  if(debug_mode) printf("\nIn dropTmpTables(). ");

  //Array used to store the DROP statement.
  char temp_sqlstmt[MAXSTMTLENGTH];

	//If the length of the table name if bigger than 0, drop it.
  if (strlen(tbl_name) > 0)
  {
    strcpy(temp_sqlstmt, "DROP TABLE ");
    strcat(temp_sqlstmt, tbl_name);

    executesqlstmt(temp_sqlstmt, 'Y', 0);
  }
}



/*----------------------------------------------------------------------------
Function name:
  buildSqlStmt 
Purpose:
  To build the select statement string for the select statement in the select 
  structure.

Parameters:
	sqlStmt           string the sql statement is to be put in.
	selectStruct      Structure containing the select statement.

Returns:
	None.
------------------------------------------------------------------------------ */
void buildSqlStmt(char* sqlStmt, SELECTSTMT* selectStruct)
{
  if(debug_mode) printf("\nIn buildSqlStmt(). ");

  //Copy the start of the select statement into sqlStmt.
  strcpy(sqlStmt, "SELECT ");

  //If the SELECTSTMT is empty, return.
  if (selectStruct == NULL)
  {
    return;
  }

  /*
    If the current statement's join flag is active, assign star to the 
    attribute list.
  */
  if (join_flag == 1)
  {
     strcat(sqlStmt, "* ");
     join_flag = 0;
  }
  else 
  {
    /*
      If there are attributes listed, add the DISTINCT keyword, and 
      the attributes.
	  */
    if (selectStruct->attributes != NULL) 
	  {
		  strcat(sqlStmt, "DISTINCT ");
		  createString(sqlStmt, selectStruct->attributes->front);
	  }
	  else
    {
      //No attributes listed, add star to attribute list.
		  strcat(sqlStmt, "* ");
    }
  }
  //Concatenate FROM keyword and tables.
  strcat(sqlStmt, "\n  FROM ");
  if(selectStruct->tables == NULL)
  {
    fprintf(stderr, "\tselectStruct->tables == NULL\n");
    return;
  }
  createString(sqlStmt, selectStruct->tables->front);

  //Add statement conditions to string.								
  if(selectStruct->conditions != NULL)
  {
    strcat(sqlStmt, "\n WHERE ");
    createString(sqlStmt, selectStruct->conditions->front);
  }

  //Add groupby portion to string.
  if(selectStruct->groupby != NULL)
  {
    strcat(sqlStmt, "\n GROUP BY ");
    createstring(sqlStmt, selectStruct->groupby->front);
  }

  //Add having portion to string.
  if(selectStruct->having != NULL)
  {
    if(debug_mode) printf("\n buildSqlStmt():having is not null, count=%d\n", selectStruct->having->count);
    strcat(sqlStmt, "\nHAVING ");
    createstring(sqlStmt, selectStruct->having->front);
  }

  //Add orderby portion to string.
  if(selectStruct->orderby != NULL)
  {
    if(debug_mode) printf("\n buildSqlStmt(): orderby is not null, count=%d\n", selectStruct->orderby->count);
    strcat(sqlStmt, "\n ORDER BY ");
    createstring(sqlStmt, selectStruct->orderby->front);
  }

  if(debug_mode) printf("\n In buildSqlStmt() method:\n\n%s\n", sqlStmt);
}



/*----------------------------------------------------------------------------
Function name:
  createString 
Purpose:
  To loop through all of the elements in a linked list and concatenate them 
  into the string sqlstring.

Parameters:
	sqlString         The string to place the elements into
	front             The front of the list containing the elements

Returns:
	None.
------------------------------------------------------------------------------ */
void createString(char* sqlString, LIST_ITEM* front)
{
  if(debug_mode) printf("\nIn createString(). ");

  /*
    Pointer used to iterate through the list and create a string of the 
    elements of the list.
  */
  LIST_ITEM* current = front;
  
  //Integer variable to keep track of the current line in the result string.
  int len = 0;

  //Iterate through the list, adding each element's string to the result string.
  while (current != NULL) 
  {
    strcat(sqlString, current->id);
    len = len + strlen(current->id);
    current = current->next;
    if (len > 200) 
    {
      strcat(sqlString, "\n");
      len = 0;
    }
  }
}



/*----------------------------------------------------------------------------
Function name:
  duplicate_att 
Purpose:
  To determine if there is common attributes in each of the attribute lists.

Parameters:
  ofront            The front of the attribute list for the first 
                    subexpression. 
	nfront            The front of the attribute list for the second 
                    subexpression.
	errormsg	        The string any error messages are to be placed in.

Returns:
	Error char equal to C if no duplicate attributes and
	equal to E if there are duplicate attributes.
------------------------------------------------------------------------------ */
char duplicate_att(LIST_ITEM *ofront, LIST_ITEM *nfront, char *errormsg)
{
  if(debug_mode) printf("\nIn duplicate_att(). ");

  //Pointer used to iterate through the second subexpression.
	LIST_ITEM *ncurrent = nfront;
	
  //Error character to be used for cleared status.
  char returncode = 'C';
	
  //Array used to store the parsed value of the current attribute.
  char tmpattribute[MAXLENGTH];
	
  /*
    Array used to store the error message to be returned if a duplicate 
    is found.
  */
  char tmpmsg[MAXERRMSGLENGTH];

  //Add beginning of error message.
	strncpy(tmpmsg, "Duplicate attributes ", MAXERRMSGLENGTH);

	/* 
    Loop through the list of attributes in the second subexpression and search 
    the list of attributes for the first subexpressiion for these attributes.
	  If any common attributes are found add them to errormsg.
  */
	while (ncurrent != NULL)
	{
		if (ncurrent->type == 'I')
		{
			if (searchlist(ncurrent->id, ofront) == 1)
			{
				if (returncode != 'C')
        {
					strcat(tmpmsg, ", ");
        } 
        parse_attribute(ncurrent->id, tmpattribute);
				strcat(tmpmsg, tmpattribute);
		    returncode = 'E';
			}
    }
		ncurrent = ncurrent->next;
	}

  /*
    If an error occurred, copy the error message to the current 
    statement's errormsg field.
	*/
  if (returncode == 'E')
  {
		strncpy(errormsg, tmpmsg, MAXERRMSGLENGTH);
		strcat(errormsg, " in tables ");
	}

  //Return the error character for the function.
	return returncode;
}



/*----------------------------------------------------------------------------
Function name:
  dividebystmt 
Purpose:
  To execute the divideby operator.

Parameters:
  subexpr1          The first subexpression of the binary op statement.
	binary_op         The divideby operator of the binary statement.
  subexpr2          The second subexpression of the binary op statement.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* dividebystmt(SELECTSTMT* abTable, SELECTSTMT* bTable)
{
  if(debug_mode) printf("\nIn dividebystmt(). ");

  //
  SELECTSTMT* aTable = NULL;
  
  //
  SELECTSTMT* allaWithAllb = NULL;
  
  //
  SELECTSTMT* aNotRelatedToSomeb = NULL;
  
  //
  SELECTSTMT* aRelatedToAllb = NULL;
  
  //
  SELECTSTMT* nselect = NULL;
  
  //Array used to hold the table name of the table to be divided.
  char abTable_name[MAXLENGTH];
  
  //Array used to hold the table name of the table dividing the ab table.
  char bTable_name[MAXLENGTH];
  
  /*
    Array used to hold the table name of the table with the columns of a 
    resulting table.
  */
  char aTable_name[MAXLENGTH];
  
  //Array used to hold the table name of a product of table a with table b.
  char allaWithAllb_name[MAXLENGTH];
  
  //Array used to hold the table name of the product with abTable rows.
  char temp_tbl_name[MAXLENGTH];
  
  /*
    Array used to hold the table name of the result of removing table b 
    columns from temp_table_name.
  */
  char aNotRelatedToSomeb_name[MAXLENGTH];
  
  //Array used to hold the table name of the table resulting from the division.
  char aRelatedToAllb_name[MAXLENGTH];

  /*
    Generate names for temporary tables for ab, b, and 'a' tables.
  */
  generate_temp_table_name(abTable_name);
  generate_temp_table_name(bTable_name);
  generate_temp_table_name(aTable_name);

  /*
    Generate temporary tables ab and b.
  */
  assignQuery(abTable_name, abTable, 1, 0);
  assignQuery(bTable_name, bTable, 0, 0);

  /*
    Check if the b table is a proper subset of the ab table.
    If it is not, throw an error.
  */
  if(propersubset(abTable_name, bTable_name) == 0)
  {
    if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
    {
      fprintf(stderr, "Not enough memory to allocate to list!");
      exit(1);
    }
    nselect->f_error = 'E';
    strcpy(nselect->errormsg, "Attributes in the table, which is on the right-hand side of divideby operator, is not a propersubset of these attributes that belong in the table on the left-hand side.");
    return nselect;
  }

  
  //Generate temporary table names.
  generate_temp_table_name(allaWithAllb_name);
  generate_temp_table_name(temp_tbl_name);
  generate_temp_table_name(aNotRelatedToSomeb_name);
  generate_temp_table_name(aRelatedToAllb_name);


  ///////////////////////////////////////////////////////////////////////////////
  /*Step 1*/
  /*Create aTable*/

  /*
    1-1:  Retrieve attributes that are within ab table that are not within
          b table.
  */
  if((aTable =(SELECTSTMT*) findattribute(abTable_name, bTable_name)) != NULL);
    
   
  /* 
    1-2:  Create aTable 
  */
  assignQuery(aTable_name, aTable, 0, 0); 


  ///////////////////////////////////////////////////////////////////////////////
  /*Step 2*/
  /*Create allaWithAllb*/

  /*
    2-1:  Signal that a divideby operation will be conducted, and that the 
          operator does not need to be converted to uppercase.
  */
  divideby_flag = 1;

  /*
    2-2:  Create a product table that has all possible combinations of 
          aTable rows and bTable rows.
  */
  allaWithAllb = (SELECTSTMT*) binaryopstmt(aTable, "TIMES", bTable);
  assignQuery(allaWithAllb_name, allaWithAllb, 1, 0);


  ///////////////////////////////////////////////////////////////////////////////
  /*Step 3*
  /*Create aRelatedToAllb*/

  /*
    3-1:  Create temp_tbl_name, a table without the abtable rows.
  */
  //Retrieve attributes from abTable, product table.
  abTable =(SELECTSTMT*) retrieveattribute(abTable_name);
  allaWithAllb =(SELECTSTMT*) retrieveattribute(allaWithAllb_name); 

  /*
    If both tables have the same attributes, assign the abTable attributes to 
    allaWithAllb.
  */
  if (compare_lists(abTable->attributes, allaWithAllb->attributes, allaWithAllb->errormsg) != 'E')
  {
    freelist(allaWithAllb->attributes);  
    allaWithAllb->attributes = abTable->attributes;
  }
  nselect = (SELECTSTMT*) binaryopstmt(allaWithAllb, "MINUS", abTable);
  assignQuery(temp_tbl_name, nselect, 1, 0); 

  /*
    3-2:  Create aNotRelatedToSomeb, a table without bTable attributes from 
          temp_tbl_name.
  */
  aNotRelatedToSomeb = (SELECTSTMT*) findattribute(temp_tbl_name, bTable_name);
  assignQuery(aNotRelatedToSomeb_name, aNotRelatedToSomeb, 0, 0); 
  
  /*Step 4*/
  /*Create aRelatedToAllb*/
  aTable = (SELECTSTMT*) findattribute(aTable_name, bTable_name);
  aRelatedToAllb = (SELECTSTMT*) binaryopstmt(aTable, "MINUS", aNotRelatedToSomeb);
  assignQuery(aRelatedToAllb_name, aRelatedToAllb, 1, 0);

  //Assign memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Add result 
  nselect->tables = addtoback(aRelatedToAllb_name, nselect->tables, 'T');  

  //Add cleared value to new statement error character.
  nselect->f_error = 'C';   

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  binaryopstmt 
Purpose:
  To execute the appropriate translation function for the binary operation 
  that was entered.

Parameters:
  subexpr1          The first subexpression of the binary op statement.
	binary_op         The binary operator of the binary statement.
  subexpr2          The second subexpression of the binary op statement.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* binaryopstmt(SELECTSTMT* subexpr1, char* binary_op, SELECTSTMT* subexpr2)
{
  if(debug_mode) printf("\nIn binaryopstmt(). ");

  /*
    Pointer used for new statement containing an operation using a binary 
    operator.
  */
  SELECTSTMT* nselect = NULL;

  //Allocate memory for new statement.
  if((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
      fprintf(stderr, "Not enough memory to allocate to list!");
      exit(1);
  }
  
  //If the operation is not a DIVIDEBY, convert the operator to uppercase.
  if(divideby_flag == 0)
  {
    uppercase(binary_op);
  }
  
  if(debug_mode) printf("\nIn binaryopstmt --%s", binary_op);
  
  /*
    If neither subexpression contains an error execute the appropriate 
    function depending on the binary operator.
  */
  if ((subexpr1) && (subexpr2) && (subexpr1->f_error != 'E') && (subexpr2->f_error != 'E'))
  {
    //If the binary operator is PRODUCT, convert to TIMES.
    if(strcmp(binary_op, "PRODUCT") == 0)
    {
      strcpy(binary_op, "TIMES");
    }

    //If the binary operator is DIFFERENCE, convert to MINUS.
    if(strcmp(binary_op, "DIFFERENCE") == 0)
    {
      strcpy(binary_op, "MINUS");
    }

    //If the binary operator is a natural join, retrieve njoin statement.
    if (strcmp(binary_op, "NJOIN")== 0 ||
        strcmp(binary_op, "NLEFTJOIN") == 0 ||
        strcmp(binary_op, "NRIGHTJOIN") == 0 ||
        strcmp(binary_op, "NFULLJOIN") == 0 )
    {
      if(debug_mode) printf("Natural Join.\n");
      nselect = (SELECTSTMT*) njoinstmt(subexpr1, subexpr2, binary_op);
    }
    //If TIMES operation, retrieve product statement.
    else if (strcmp(binary_op, "TIMES") == 0)
    {
      nselect = (SELECTSTMT*) productstmt(subexpr1, subexpr2);
    }
    //If set operation, retrieve set operation statement.
    else if ((strcmp(binary_op, "UNION") == 0) || (strcmp(binary_op, "MINUS") == 0)
            || (strcmp(binary_op, "INTERSECT") == 0))
    {
      nselect = (SELECTSTMT*) setopstmt(subexpr1, binary_op, subexpr2);
    }
    //If divideby operation, retrieve divideby statement.
    else if(strcmp(binary_op, "DIVIDEBY") == 0)
    { 
      nselect = (SELECTSTMT*) dividebystmt(subexpr1, subexpr2);
      divideby_flag = 0;
    }
    //Otherwise, invalid binary operation, return error.
    else
    {
      nselect->f_error = 'E';
      strcpy(nselect->errormsg, "Unknown binary operation!");
    }
  }
  else
  {
    /*
      If either of these subexpressions contains an error pass this 
      error on.
    */
    strncpy(nselect->errormsg, subexpr1->errormsg, MAXERRMSGLENGTH);
    strcat(nselect->errormsg, " ");
    strcat(nselect->errormsg, subexpr2->errormsg);
    nselect->f_error = 'E';
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);
  }

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  joinstmt 
Purpose:
  To translate a relational algebra theta join statement into its 
  corresponding select statement.

Parameters:
  subexpr1          The first subexpression of the join statement.
  subexpr2          The second subexpression of the join statement.
  attribute1        The attribute from subexpression1 to compare.
  relop             The relational operator to compare the attributes by.
  attribute2        The attribute from subexpression2 to compare.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* joinstmt(SELECTSTMT* subexpr1, SELECTSTMT* subexpr2, char* attribute1, char* relop, char* attribute2)
{
  if(debug_mode) printf("\nIn joinstmt(). ");

  //Pointer used for a new statement that will hold the join.
  SELECTSTMT* nselect = NULL;
  
  /*
    Error message for the merge and prefix operation on the second 
    subexpression.
  */
  char tempmsg[MAXERRMSGLENGTH];
  
  /*
    Error message from an operation to check for duplicate columns.
  */
  char tempmsg2[MAXERRMSGLENGTH];
  
  /*
    Error char for the merge and prefix operation on the first 
    subexpression.
  */
  char f_error1 = '\0';
  
  /*
    Error message for the merge and prefix operation on the second 
    subexpression.
  */
  char f_error2 = '\0';
  
  /*
    Error message from an operation to check for duplicate columns.
  */
  char f_error3 = '\0';
  
  /*
    Pointer to the list that contains join conditions for the first 
    subexpression.
  */
  LIST* jcond1 = NULL;
  
  /*
    Pointer to the list that contain join conditions for the second 
    subexpression.
  */
  LIST* jcond2 = NULL;

  // Allocate memory to the new select statement structure.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  /*
    If the first subexpression contains an error, flag the new statement 
    and return it.
  */
  if(subexpr1->f_error == 'E')
  {
    nselect->f_error = 'E';
    strncpy(nselect->errormsg, subexpr1->errormsg, MAXERRMSGLENGTH);
    return nselect;	
  }
  /*
    If the second subexpression contains an error, flag the new statement 
    and return it.
  */
  if(subexpr2->f_error == 'E')
  {
    nselect->f_error = 'E';
    strncpy(nselect->errormsg, subexpr2->errormsg, MAXERRMSGLENGTH);
    return nselect;	
  }
  
  /* 
    Add the attributes of the tables in the subexpressions if they are not
    already present.
  */
  if ((subexpr1->attributes == NULL) && (subexpr1->tables->front->next == NULL))
  {
    addattributes(subexpr1->tables->front->id, subexpr1);
  }
  if ((subexpr2->attributes == NULL) && (subexpr2->tables->front->next == NULL))
  {
    addattributes(subexpr2->tables->front->id, subexpr2);
  }

  /*
    Add join conditions, merge with first subexpression's attribute list, 
    and add table prefixes.
  */
  jcond1 = addtolist(relop, jcond1, 'E');
  jcond1 = addtolist(attribute1, jcond1, 'I');
  f_error1 = addptablename(jcond1->front, subexpr1->attributes->front, nselect->errormsg);

  /*
    Add join conditions, merge with second subexpression's attribute list, 
    and add table prefixes.
  */
  jcond2 = addtolist(") ", jcond2, 'E'); 
  jcond2 = addtolist(attribute2, jcond2, 'I'); 
  f_error2 = addptablename(jcond2->front, subexpr2->attributes->front, tempmsg);

  //Check if the two subexpressions have any duplicate attributes.
  f_error3 = duplicate_att(subexpr1->attributes->front, subexpr2->attributes->front, tempmsg2);

  /*
    Add the attributes of the two subexpressions to the attributes of the new
    select statement.
  */
  subexpr2->attributes = addtolist(", ", subexpr2->attributes, 'E');
  nselect->attributes = mergelist(subexpr1->attributes, subexpr2->attributes);

  if ((f_error1 != 'E') && (f_error2 != 'E'))
  {
  /* 
    Add any conditions from the subexpressions and the comparison join condition
    to the conditions of the new select statement and add the tables of the
    subexpressions to the new select statement.
  */
    if((subexpr1->conditions != NULL) && (subexpr2->conditions == NULL))
    {
      nselect->conditions = subexpr1->conditions;
      nselect->conditions = addtolist(" AND ", nselect->conditions, 'E'); 
    }
    else if((subexpr1->conditions == NULL) && (subexpr2->conditions != NULL))
    {
      nselect->conditions = subexpr2->conditions;
      nselect->conditions = addtolist(" AND ", nselect->conditions, 'E'); 
    }
    else if((subexpr1->conditions != NULL) && (subexpr2->conditions != NULL))
    {
	    subexpr2->conditions = addtolist(" AND ", subexpr2->conditions, 'E');
      nselect->conditions = mergelist(subexpr1->conditions, subexpr2->conditions);
      nselect->conditions = addtolist(" AND ", nselect->conditions, 'E');
    }

    //Merge the join conditions and print them out if debug mode is active.
    jcond1 = mergelist(jcond1, jcond2);
    printList_i(jcond1);

    //Add join conditions to current conditions.
    nselect->conditions = mergelist(jcond1,  nselect->conditions);
    nselect->conditions = addtolist(" (", nselect->conditions, 'E');

    //Add join conditions to table list of new statement.
    nselect->conditions = addtolist(" ON", nselect->conditions, 'E');
    subexpr2->tables = mergelist(subexpr2->tables, nselect->conditions);
    nselect->conditions = NULL;
    subexpr2->tables = addtolist(" JOIN ", subexpr2->tables, 'E');
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);

    //Flip join flag to signal a join condition is in the statement.
    join_flag = 1;

    /*
      If the third error character indicates an error occurred,
      remove duplicates.
    */
    if (f_error3 == 'E')
    {
       remove_duplicated_column(nselect);			
    }
  }
  else
  {
    /*
      If either of the comparison attributes was not found in their 
      corresponding subexpression table.
    */
    //Free memory inside subexpressions.
	  freeexpr(subexpr1);
	  freeexpr(subexpr2);

    //Add text to accompany error message to reflect errors.
	  if (f_error2 == 'E')
  	{
	    if (f_error1 == 'E')
      {
        strcat(nselect->errormsg, " AND ");
      }
      strcat(nselect->errormsg, tempmsg);
    }

	  strcat(nselect->errormsg, " in condition of join statement.");
    nselect->f_error = 'E';
    
    //Free jcond2 list.
    free(jcond2);

    /* 
      If either of the subexpressions contains an error pass these errors
	    on instead of translating the statement.
    */
    strncpy(nselect->errormsg, subexpr1->errormsg, MAXERRMSGLENGTH);
    strcat(nselect->errormsg, " ");
    strcat(nselect->errormsg, subexpr2->errormsg);
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);
    nselect->f_error = 'E';
  }
  //Free memory for subexpressions.
  free(subexpr1);
  free(subexpr2);
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  njoinstmt 
Purpose:
  To translate a relational algebra njoin statement into its corresponding 
  select statement.

Parameters:
  subexpr1	        The first subexpression of the njoin statement.
  subexpr2          The second subexpression of the njoin statement.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* njoinstmt(SELECTSTMT* subexpr1, SELECTSTMT* subexpr2, char* binary_op)
{
  if(debug_mode) printf("\nIn njoinstmt(). ");

  //Pointer for the new statement that will contain the njoin.
  SELECTSTMT* nselect = NULL;
  
  //Pointer to the list that will contain the join condition for an njoin.
  LIST* jcond = NULL;
  
  //Pointer used to iterate through attribute lists.
  LIST_ITEM* current = NULL;

  //Allocate memory to new select statement structure.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }
 
  /*
    Assign front of the second subexpression's attribute list to pointer.
  */
  current = subexpr2->attributes->front;

  /*
    Add the attributes to the subexpression select statements if they are not
    already present.
  */
  if ((subexpr1->attributes == NULL) && (subexpr1->tables != NULL) && (subexpr1->tables->front != NULL))
  {
    addattributes(subexpr1->tables->front->id, subexpr1);
  }
  if ((subexpr2->attributes == NULL) && (subexpr2->tables != NULL) && (subexpr2->tables->front != NULL))
  {
    addattributes(subexpr2->tables->front->id, subexpr2);
  }

  //Find the common attributes between the two subexpressions to join them by.
  if((subexpr1->attributes) && (subexpr1->attributes->front) && (subexpr2->attributes) && (subexpr2->attributes->front))
  {
    jcond = common_join_att(subexpr1->attributes->front, subexpr2->attributes->front, "=");
  }
  else
  {
    if(debug_mode) printf("\nIn joinstmt(): Either subexpr1 or subexpr2 not in correct state");
  }

  //Add the attributes of the subexpressions to the new select statement.
  if ((jcond != NULL))
  { 
    subexpr2->attributes = addtolist(", ", subexpr2->attributes, 'E');
  }
  else
  {
    strcpy(nselect->errormsg, "Can not do a njoin or outer join, no common attributes.");
    nselect->f_error = 'E';
    return nselect;
  }
  nselect->attributes = mergelist(subexpr1->attributes, subexpr2->attributes);

  //Testing block.
  /*
        // T E S T I N G
        //
        //
        current = nselect->attributes->front;
        while (current != NULL)
        {
          printf("%s\n", current->id);
          current = current->next;
        } 
  */

  // remove the duplicated attributes from attribute list
  current = jcond->front;
  int elementCount = 0;
  while (current != NULL)
  {
    //printf("%s\n", current->id);
    if(current->type == 'I')
    {
      elementCount++;
      if(elementCount % 2 == 1)
      {
        //printf("TESTING: %s", current->id);
        removeFromBack(current->id, nselect->attributes);
      }
    }
    current = current->next;
  } 

  //Testing block.
  /*
          // T E S T I N G
          //
          //
          current = nselect->attributes->front;
          while (current != NULL)
          {
            printf("%s\n", current->id);
            current = current->next;
          } 
  */
           
  // Add the conditions of the subexpressions and the common attribute join
  // conditions to the new select statement.
  if((subexpr1->conditions != NULL) && (subexpr2->conditions == NULL))
  {
    nselect->conditions = subexpr1->conditions;
  }
  else if((subexpr1->conditions == NULL) && (subexpr2->conditions != NULL))
  {
    nselect->conditions = subexpr2->conditions;
  }
  else if((subexpr1->conditions != NULL) && (subexpr2->conditions != NULL))
  {
    subexpr2->conditions = addtolist(" AND ", subexpr2->conditions, 'E');
    nselect->conditions = mergelist(subexpr1->conditions, subexpr2->conditions);
  }

  if((nselect->conditions != NULL) && (jcond != NULL))
  {
    nselect->conditions = addtolist(" AND ", nselect->conditions, 'E'); 
    nselect->conditions = mergelist(jcond,  nselect->conditions);
  }
  else if((nselect->conditions == NULL) && (jcond != NULL))
    nselect->conditions = jcond; 
        
  // Add the tables of the subexpressions to the new select statement. 
  if(strcmp(binary_op, "NJOIN") != 0)
  {
    subexpr2->tables = addtolist("? ", subexpr2->tables, 'E');
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);
  }
  else
  {
    subexpr2->tables = addtolist(", ", subexpr2->tables, 'E');
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);
  }

  /*
    Set the new statement's error char to cleared.
  */
  nselect->f_error = 'C';

  //If the njoin is not only an njoin.
  if(strcmp(binary_op, "NLEFTJOIN") == 0 ||
      strcmp(binary_op, "NRIGHTJOIN") == 0 ||
      strcmp(binary_op, "NFULLJOIN") == 0)
  {
    //Pointer used to point to the string following the dot operator.
    char* tok = NULL;
    
    //Array used to store the parsed attribute.
    char nattribute[MAXLENGTH];
    nattribute[0]='\0';
    
    /*
      If the new statement has a single resulting table and at least 1 
      attribute, then remove the prefixes of the table off the attributes.
    */
    if(nselect->tables->count = 1 && nselect->attributes->count > 0)
    {
      current = nselect->attributes->front;
      while(current != NULL)
      {
        if(current->type == 'I')
        {
          tok = strstr(current->id, ".");
          if(tok != NULL)
          {
            parse_attribute(current->id, nattribute);
            strcpy(current->id, nattribute);
          }
        }
        current = current->next;
      }
    }
  }
  /*
    If the relative operator is not 'njoin'.
  */
  if (strcmp(binary_op, "NJOIN") != 0)
  {
    add_outerjoin_stmt(nselect, binary_op);
  }

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  outerjoinstmt 
Purpose:
  To translate a relational algebra join statement into its corresponding 
  select statement.

Parameters:
  subexpr1          The first subexpression of the outer join statement.
	subexpr2          The second subexpression of the outer join statement.
	binary_op         The outer join operator.
	attribute         The attribute provided for outer join.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* outerjoinstmt(SELECTSTMT* subexpr1, SELECTSTMT* subexpr2, char* binary_op, char* attribute)
{
  if(debug_mode) printf("\nIn outerjoinstmt(). ");

  //Pointer for the statement that will contain an outer join.
  SELECTSTMT* nselect = NULL;
  
  /*
    Pointer to list that will contain the join condition containing the 
    attributes common to both subexpressions.
  */
  LIST* jcond = NULL;
  
  /*
    Pointer used to iterate through the jcond list, and the attribute lists 
    for both subexpressions.
  */
  LIST_ITEM* current = NULL;
  
  //Pointer to list used to create join condition.
  LIST* templist = NULL;

  //Convert condition elements to uppercase.
  uppercase(binary_op);
  uppercase(attribute);

  //Allocate memory to new select statement structure.
  if((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  /*
    If the first subexpression contains an error, change the error status of 
    the new statement.
  */
  if(subexpr1->f_error == 'E')
  {
    strcpy(nselect->errormsg, subexpr1->errormsg);
    nselect->f_error = 'E';
    return nselect;
  }

  /*
    If the second subexpression contains an error, change the error status of 
    the new statement.
  */
  if(subexpr2->f_error == 'E')
  {
    strcpy(nselect->errormsg, subexpr2->errormsg);
    nselect->f_error = 'E';
    return nselect;
  }

  /* 
    Add the attributes to the subexpression select statements if not already
    done so.
  */
  if((subexpr1->attributes == NULL) && (subexpr1->tables->front->next == NULL))
  {
    addattributes(subexpr1->tables->front->id, subexpr1);
  }

  if ((subexpr2->attributes == NULL) && (subexpr2->tables->front->next == NULL))
  {
    addattributes(subexpr2->tables->front->id, subexpr2);
  }

  //Find the common attributes between the two subexpressions to join them by.
  jcond = common_join_att(subexpr1->attributes->front, subexpr2->attributes->front, "=");

  /*
    If jcond is not empty, check if the variable provided as the join 
    condition is found amongst the common attributes. Reform jcond to only 
    contain that attribute if it is found.
  */
  if(jcond != NULL && jcond->front !=NULL && jcond->front->next !=NULL && attribute != NULL)
  {
    //Array used to store the parsed attribute in a jcond element.
    char nattribute[MAXLENGTH];

    /*
      Integer variable used to indicate if the join condition was found 
      in jcond.
    */
    int found = 0;

    //Iterate through jcond looking for the join condition attribute.
    current = jcond->front;
    while(current!=NULL)
    {
      parse_attribute(current->id, nattribute);
      if(strcmp(attribute, nattribute) == 0)
      {
        found = 1;
        break;
      }
      current = current->next;
    }

    //Remake jcond to only use the join condition.
    freelist(jcond);
    jcond = NULL;
    if(found == 1)
    {
      //Start jcond.
      jcond = addtoback("(", jcond, 'E');
      //First common attribute.
      strcpy(nattribute, subexpr1->tables->front->id);
      strcat(nattribute, ".");
      strcat(nattribute, attribute);
      jcond = addtoback(nattribute, jcond, 'I');
      //Relative operator.
      jcond = addtoback(" ", jcond, 'E');
      jcond = addtoback(binary_op, jcond, 'E');
      jcond = addtoback(" ", jcond, 'E');
      //Second common attribute.
      strcpy(nattribute, subexpr2->tables->front->id);
      strcat(nattribute, ".");
      strcat(nattribute, attribute);
      jcond = addtoback(nattribute, jcond, 'I');
      //Close jcond.
      jcond = addtoback(")", jcond, 'E');
    }
  }
  else{
    //Free jcond and set NULL if join attribute not common.
    if(jcond != NULL)
    {
      freelist(jcond);
      jcond = NULL;
    }
  }

  /*
    Add the attributes of the second subexpression to the first subexpression.
  */
  if((jcond != NULL))
  { 
    subexpr2->attributes = addtolist(", ", subexpr2->attributes, 'E');
  }
  else
  {
    strcpy(nselect->errormsg, "Can not do a njoin or outer join, no common attributes.");
    nselect->f_error = 'E';
    return nselect;
  }
  nselect->attributes = mergelist(subexpr1->attributes, subexpr2->attributes);   


  /* 
    Add the conditions of the subexpressions and the common attribute join 
    conditions to the new select statement. 
  */
  if((subexpr1->conditions != NULL) && (subexpr2->conditions == NULL))
  {
    nselect->conditions = subexpr1->conditions;
  }
  else if((subexpr1->conditions == NULL) && (subexpr2->conditions != NULL))
  {
    nselect->conditions = subexpr2->conditions;
  }
  else if((subexpr1->conditions != NULL) && (subexpr2->conditions != NULL))
  {
    subexpr2->conditions = addtolist(" AND ", subexpr2->conditions, 'E');
    nselect->conditions = mergelist(subexpr1->conditions, subexpr2->conditions);
  }

  //To build Form statement in SQL.
  templist = NULL;
  templist = addtolist(")", templist, 'E');
  templist = addtolist(")", templist, 'E');

  /*
    Array used to temporarily store the value of the second 
    subexpression's current attribute.
  */
  char nattribute[MAXLENGTH];
  
  /*
    Array used to temporarily store the value of the first 
    subexpression's current attribute.
  */
  char oattribute[MAXLENGTH];
 
  /*
    Iterate through the subexpression's attributes until the join condition 
    attribute is found.
  */
  current = subexpr2->attributes->front;
  while (current != NULL)
  {
	  parse_attribute(current->id, nattribute);
	  if(strcmp(nattribute, attribute) == 0)
	  {
		  templist = addtolist(current->id, templist, 'I');
		  break;
	  }
	  current = current->next;
  }

  //Add equality operator to templist.
  templist = addtolist(" = ", templist, 'E');

  /*
    Iterate through the subexpression's attributes until the join condition 
    attribute is found.
  */
  current = subexpr1->attributes->front;
  while (current != NULL)
  {
	  parse_attribute(current->id, oattribute);
	  if(strcmp(oattribute, attribute) == 0)
	  {
		  templist = addtolist(current->id, templist, 'I');
		  break;
	  }
	  current = current->next;
  }

  /*
    Add opening bracket and keyword, merge templist to the second 
    subexpression's table list.
  */
  templist = addtolist("(", templist, 'E');
  templist = addtolist(" ON ", templist, 'E');
  templist = mergelist(subexpr2->tables, templist);
  
  /*
    Add outer join keywords to templist and then merge that list with the 
    first subexpression's table list.
  */
  if(strcmp(binary_op, "LEFTJOIN") == 0)
  {
    templist = addtolist(" left outer join ", templist, 'E');
  }
  else if(strcmp(binary_op, "RIGHTJOIN") == 0)
  {
	  templist = addtolist(" right outer join ", templist, 'E');
  }
  else if(strcmp(binary_op, "FULLJOIN") == 0)
  {
    templist = addtolist(" full outer join ", templist, 'E');
  }
  nselect->tables = mergelist(subexpr1->tables, templist);
  nselect->tables = addtolist("(", nselect->tables, 'E');

  /*
    Set new statement's error char to cleared.
  */
  nselect->f_error = 'C';
  
  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  printList_i 
Purpose:
	Print the elements in the list (just for error check).

Parameters:
  p_list            A list.

Returns:
  None.
------------------------------------------------------------------------------ */
void printList_i(LIST* p_list)
{
  if(debug_mode) printf("\nIn printList_i(). ");

  //Pointer used to iterate through the list that must be printed.
  LIST_ITEM* current = NULL;
  
  //Array used to hold the string of elements in the list.
  char temp[MAXSTMTLENGTH];

  //If the list is empty, then print a message and return.
  if (p_list == NULL)
  {
    if(debug_mode) printf("\nList is empty.");
    return;
  }

  //Assign front of the list to pointer.
  current = p_list->front;

  //Copy first attribute value to the start of the list.
  strcpy(temp, current->id);

  //Iterate through the list and add the attribute values to the string.
  current = current->next;
  while(current != NULL)
  {
    strcat(temp, " ");
    strcat(temp, current->id);
    current = current->next;
  }

  if(debug_mode) printf("\nstring in the list:\n%s\n", temp);
}



/*----------------------------------------------------------------------------
Function name:
  common_join_att 
Purpose:
  To find attributes that are common between two subexpressions and return a 
  list of join conditions containing these attributes.

Parameters:
	nfront            List of attributes in the first subexpression.
	ofront            List of attributes in the second subexpression.
	relop             The relational operator to place between common 
                    attributes in the join conditions.

Returns:
  Returns a list containing the common attribute join conditions.
------------------------------------------------------------------------------ */
LIST* common_join_att(LIST_ITEM* nfront, LIST_ITEM* ofront, char* relop)
{
  if(debug_mode) printf("\nIn common_join_att(). ");

  //Pointer used to iterate through the first subexpression.
  LIST_ITEM* ncurrent   = NULL;
  
  //Pointer used to iterate through the second subexpression.
  LIST_ITEM* ocurrent   = NULL;
  
  /*
    Pointer user to refer to the LIST_ITEM preceding the current element of 
    the second subexpression.
  */
  LIST_ITEM* oprevious  = NULL;
  
  /*
    Pointer to list containing the common attribute expressions between the 
    two subexpression.
  */
  LIST* common_att = NULL;
  
  /*
    Array used to temporarily store the parsed value of the current attribute 
    of the first subexpression.
  */
  char nattribute[MAXLENGTH];
  
  /*
    Array used to temporarily store the parsed value of the current attribute 
    of the second subexpression.
  */
  char oattribute[MAXLENGTH];

  /*
    Assign initial value of pointers to be the front of the subexpression 
    lists.
  */
  ncurrent = nfront;
  ocurrent = ofront;

  /*
    Loop through the list attributes for the first subexpression finding any 
    common attributes in the list of the second subexpression and adding 
    these to the list of join conditions to be returned.
  */
  while (ncurrent != NULL)
  {
		if (ncurrent->type == 'I' && (ocurrent)) 
		{
      //Assign parsed values to nattribute/oattribute.
			parse_attribute(ncurrent->id, nattribute);
			parse_attribute(ocurrent->id, oattribute);

      //Iterate through the second subexpression. Stop if the attributes match.
			while ((ocurrent) && (ncurrent) && (strncmp(oattribute, nattribute, MAXLENGTH) != 0))
			{
				oprevious = ocurrent;
				ocurrent = ocurrent->next;

        //If the current second subexpression element is an attribute, parse.
				if ((ocurrent) && (ocurrent->type == 'I'))
        {
					parse_attribute(ocurrent->id, oattribute);
        }
			}

      /*
        If the second subexpression's current element is not NULL, then add an 
        entry to common_att for these common attributes.
			*/
      if (ocurrent)
			{
				if (common_att == NULL)
				{
          common_att = addtolist(") ", common_att, 'E');
        }
        else
        {
				  common_att = addtolist(" AND ", common_att, 'E');
        }

				common_att = addtolist(ncurrent->id, common_att, 'I');
        common_att = addtolist(" ", common_att, 'E');
				common_att = addtolist(relop, common_att, 'E');
        common_att = addtolist(" ", common_att, 'E');
				common_att = addtolist(ocurrent->id, common_att, 'I');
                                
				//ocurrent->type = 'C';

				if (oprevious != NULL)
        {
					//oprevious->type = 'C';
        }
			}
      //Reset pointer to be the front of the second subexpression.
			ocurrent = ofront;
		}
    //Iterate pointer for first subexpression.
		ncurrent = ncurrent->next;
  }

  /*
    If the list of common attributes is not empty, then add the last 
    element of the list.
	*/
  if(common_att)
  {
		common_att = addtolist("(", common_att, 'E');
  }

  //Return list of common attribute expressions.
	return common_att;
}



/*----------------------------------------------------------------------------
Function name:
  productstmt 
Purpose:
  To translate a relational algebra product statement into its corresponding 
  select statement.

Parameters:
  subexpr1          The first subexpression of the product statement.
	subexpr2          The second subexpression of the product statement.

Returns:
	Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* productstmt(SELECTSTMT* subexpr1, SELECTSTMT* subexpr2)
{
  if(debug_mode) printf("\nIn productstmt(). ");

  //Pointer for the new statement that includes the product operation.
  SELECTSTMT *nselect = NULL;

  //Pointer used to iterate through the first subexpr1.
  LIST_ITEM* current = NULL;
  
  //Array used to format table attributes to include a table prefix.
  char temp_string3[MAXLENGTH];
  temp_string3[0] = '\0';
  
  //Pointer to token following dot operator.
  char* tok = NULL;
  
  //Character used to indicate whether an error has occurred.
  char f_error = '\0';

  //
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Add the attributes to the subexpressions if not allready done.
  if ((subexpr1->attributes == NULL) && (subexpr1->tables->front->next == NULL))
    addattributes(subexpr1->tables->front->id, subexpr1);
       
  if ((subexpr2->attributes == NULL) && (subexpr2->tables->front->next == NULL))
    addattributes(subexpr2->tables->front->id, subexpr2);

  /*
    If the first subexpression only has 1 table, and it includes attributes,
    then add a prefix to each attribute for the product operation.
  */
  if(subexpr1->tables->count == 1 && subexpr1->attributes->count > 0)
  {
    current = subexpr1->attributes->front;
    while(current != NULL)
    {
      if(current->type == 'I')
      {
        /*
          Take token after dot operator. If NULL, then add prefix to 
          attribute.
        */
        tok = strstr(current->id, ".");
        if(tok == NULL)
        {
          strcpy(temp_string3, subexpr1->tables->front->id);
          strcat(temp_string3, ".");
          strcat(temp_string3, current->id);
          strcpy(current->id, temp_string3);
        }
      }
      current = current->next;
    }
  }
  
  /*
    If the second subexpression only has 1 table, and it includes attributes,
    then add a prefix to each attribute for the product operation.
  */
  if(subexpr2->tables->count == 1 && subexpr2->attributes->count > 0)
  {
    current = subexpr2->attributes->front;
    while(current != NULL)
    {
      if(current->type == 'I')
      {        
        /*
          Take token after dot operator. If NULL, then add prefix to 
          attribute.
        */
        tok = strstr(current->id, ".");
        if(tok == NULL)
        {
          strcpy(temp_string3, subexpr2->tables->front->id);
          strcat(temp_string3, ".");
          strcat(temp_string3, current->id);
          strcpy(current->id, temp_string3);
        }
      }
      current = current->next;
    }
  }

  //If both subexpression do not contain errors.
  if (subexpr1->f_error != 'E' && subexpr2->f_error != 'E')
  {

    /*
      Add the attributes, conditions, and tables of both subexpressions to the
      new select statement.
    */
    subexpr2->attributes = addtolist(", ", subexpr2->attributes, 'E');
    nselect->attributes = mergelist(subexpr1->attributes, subexpr2->attributes);     
    if ((subexpr1->conditions != NULL) && (subexpr2->conditions == NULL))
    {
	    nselect->conditions = subexpr1->conditions;
    }
    else if ((subexpr1->conditions == NULL) && (subexpr2->conditions != NULL))
    {
      nselect->conditions = subexpr2->conditions;
    }
    else if ((subexpr1->conditions != NULL) && (subexpr2->conditions != NULL))
    {
      subexpr2->conditions = addtolist(" AND ", subexpr2->conditions, 'E');
      nselect->conditions = mergelist(subexpr1->conditions, subexpr2->conditions);
    }
    subexpr2->tables = addtolist(", ", subexpr2->tables, 'E');
    nselect->tables = mergelist(subexpr1->tables, subexpr2->tables);
  }
  else
  {
    /* If the two subexpressions had any errors. */
    freeexpr(subexpr1);
    freeexpr(subexpr2);
    strcat(nselect->errormsg, "Error in product statement.");
    nselect->f_error = 'E';
  }

  //Return statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  setopstmt 
Purpose:
  To translate a relational algebra set operation statement into its 
  corresponding select statement.

Parameters:
  subexpr1          The first subexpression of the set operation.
  set_op            The set operation to be performed between the subexpressions.
  subexpr2          The second subexpression of the set operation.

Returns:
  Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* setopstmt(SELECTSTMT* subexpr1, char* set_op, SELECTSTMT* subexpr2)
{
  if(debug_mode) printf("\nIn setopstmt(). ");

  //Pointer to the new statement containing the set operation.
  SELECTSTMT* nselect = NULL;
  
  //Character used to indicate whether an error has occurred.
  char f_error = '\0';
  
  //Array used to temporarily store a generated temp table name.
  char temptable_1[MAXLENGTH];
  
  //Array used to temporarily store a new SQL statement.
  char tempquery[MAXSTMTLENGTH];
  
  /*
    Array used to temporarily store the first subexpr1 (and a merged 
    statement between subexpr1 and subexpr2).
  */
  char newsqlstmt1[MAXSTMTLENGTH];

  //Array used to temporarily store the subexpr2.
  char newsqlstmt2[MAXSTMTLENGTH];

  //Allocate memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  } 
 
  //Add the attributes to the subexpressions if not already done so.
  if ((subexpr1->attributes == NULL) && (subexpr1->tables->front->next == NULL))
  {
    addattributes(subexpr1->tables->front->id, subexpr1);
  } 
  if ((subexpr2->attributes == NULL) && (subexpr2->tables->front->next == NULL))
  {
    addattributes(subexpr2->tables->front->id, subexpr2);
  }
     

  //Check if the subexpressions contain the same attributes.
  f_error = compare_lists(subexpr1->attributes, subexpr2->attributes, nselect->errormsg);
  
  //If an error was raised, set the status in the new statement.
  if (f_error == 'E')
  {
    /*
      If the subexpressions do not contain the same attributes raise an error. 
    */
    nselect->f_error = 'E';
		
    strcat(nselect->errormsg, " in ");
    strcat(nselect->errormsg, set_op);
  }
  else
  {
    //Else, build the new statement containing the set operation.
    if(sql_flag == 1)
    {
      buildselectstmt(newsqlstmt1, subexpr1);
    }
    else
    {
      buildSqlStmt(newsqlstmt1, subexpr1);
    }
    
    buildSqlStmt(newsqlstmt2, subexpr2);


    strcat(newsqlstmt1, "\n");
    strcat(newsqlstmt1, set_op);
    strcat(newsqlstmt1, "\n");
    strcat(newsqlstmt1, newsqlstmt2);
               
    generate_temp_table_name(temptable_1);

    //Create SQL statement to be executed creating a temporary table.
    strcpy(tempquery, "CREATE TABLE ");
    strcat(tempquery, temptable_1);
    strcat(tempquery, " AS\n");
    strcat(tempquery, newsqlstmt1);

    //Execute SQL statement.
    executesqlstmt(tempquery, 'Y', 0);

    //Add temp table to the new statement's table list.
    nselect->tables = addtolist(temptable_1, nselect->tables, 'T');
  }
 
  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  condition_list 
Purpose:
  To add conditions separated by an or to a list and return a structure 
  containing this list.

Parameters:
  andcondlist       Sublist of conditions separted by 'and's.
	condlist          Sublist of conditions.

Returns:
	Pointer to the structure containing the list of conditions.
------------------------------------------------------------------------------ */
SELECTSTMT* condition_list(SELECTSTMT* andcondlist, SELECTSTMT* condlist)
{
  if(debug_mode) printf("\nIn condition_list(). ");

  /*
    Pointer for a statement that will separate additional conditions by an 
    'OR' operator.
  */
  SELECTSTMT* nselect = NULL;

  //Allocate memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Close the currently opened parenthesis.
  nselect->conditions = addtolist(") ", nselect->conditions, 'E');

  /*
    If the additional condition list is not empty, add it to the new 
    statement and add an 'OR' operator.
  */
  if (condlist != NULL)
  {
    nselect->conditions = mergelist(condlist->conditions, nselect->conditions);
    nselect->conditions = addtolist(" OR ", nselect->conditions, 'E');
  }

  /*
    Merge the new statement and the other condition list, and append 
    opening bracket.
  */
  nselect->conditions = mergelist(andcondlist->conditions, nselect->conditions);
  nselect->conditions = addtolist(" (", nselect->conditions, 'E');

  //Set status to cleared.
  nselect->f_error = 'C';

  //Return the statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  andcond_list 
Purpose:
  To add conditions separated by an and to a list and return a structure 
  containing this list.

Parameters:
	relformula        Sublist of relational conditions.
	andcondition      Sublist of conditions separted by 'and's.

Returns:
  Pointer to the structure containing the list of conditions.
------------------------------------------------------------------------------ */
SELECTSTMT* andcond_list(SELECTSTMT* relformula, SELECTSTMT* and_condition)
{
  if(debug_mode) printf("\nIn andcond_list(). ");
  
  /*
    Pointer for a new statement containing 'and' operators.
  */
  SELECTSTMT* nselect = NULL;

  //If the and_condition statement is null, we do not need to add it.
  if (and_condition == NULL)
  {
    nselect = relformula;
  }
  else
  {
    //Allocate memory for new statement.
    if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
    {
      fprintf(stderr, "Not enough memory to allocate to list!");
      exit(1);
    }

    //Add operator to the existing list and merge the lists.
    nselect->conditions = addtolist(" AND ", and_condition->conditions, 'E');
    nselect->conditions = mergelist(relformula->conditions, nselect->conditions);
  }

  //Return the updated statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  rel_formula1 
Purpose:
  To add relational conditions to a list and return a structure containing 
  this list.

Parameters:
  operand1          The operands of the relational condition.
	operand2          The operand (next to operands) of the relational 
                    condition.

Returns:
  Pointer to the structure containing the list of relational conditions.
------------------------------------------------------------------------------ */
SELECTSTMT* rel_formula1(SELECTSTMT* operand1, char* relop, SELECTSTMT* operand2)
{
  if(debug_mode) printf("\nIn rel_formula1(). ");

  //Pointer for the statement that will hold the new condition.
  SELECTSTMT* nselect = NULL;

  //Testing block
  /* 
          LIST_ITEM  *tmp_item = NULL;

          tmp_item = operand1->conditions->front;
          while (tmp_item != NULL)
          {
            printf("\n In rel_formula1(): tmp_item->id is : %s , tmp_item->typr is : %c", tmp_item->id, tmp_item->type);
            tmp_item = tmp_item->next;
          }
          printf("\n\n");
          tmp_item = operand2->conditions->front;
          while (tmp_item != NULL)
          {
            printf("\n In rel_formula1(): tmp_item->id is : %s , tmp_item->typr is : %c", tmp_item->id, tmp_item->type);
            tmp_item = tmp_item->next;
          }
          printf("\n\n");
  */ 

  //Assign operand2 statement to nselect.
	nselect = operand2;
  /*
    Add space, new relative operator, new space to the statement's conditions.
	*/
  nselect->conditions = addtolist(" ", nselect->conditions, 'E');
	nselect->conditions = addtolist(relop, nselect->conditions, 'E');
	nselect->conditions = addtolist(" ", nselect->conditions, 'E');

  /*
    Merge the original statement's conditions to the nselect statement's 
    conditions.
	*/
  nselect->conditions = mergelist(operand1->conditions, nselect->conditions);
  
  //Testing block
  /*
          tmp_item = nselect->conditions->front;
          while (tmp_item != NULL)
          {
            printf("\n In executesql(): tmp_item->id is : %s , tmp_item->typr is : %c", tmp_item->id, tmp_item->type);
            tmp_item = tmp_item->next;
          }
          printf("\n\n"); 
  */

  //Return updated statement.
 	return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  rel_formula2 
Purpose:
  To add a parenthesized condition to a list and return a structure 
  containing this list.

Parameters:
  condlist          The sublist of conditions to be added to the list.

Returns:
  Pointer to the structure containing the parenthesized conditions list.
------------------------------------------------------------------------------ */
SELECTSTMT* rel_formula2(SELECTSTMT* condlist)
{
  if(debug_mode) printf("\nIn rel_formula2(). ");

  //Pointer for the statement containing the new condition.
  SELECTSTMT* nselect = NULL;
  
  //Allocate memory for the new statement.
	if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
	{
		fprintf(stderr, "Not enough memory to allocate to list!");
		exit(1);
	}

  //Close previous parenthesis, add existing conditions, add opening bracket.
	nselect->conditions = addtolist(") ", nselect->conditions, 'E');
  nselect->conditions = mergelist(condlist->conditions, nselect->conditions);
	nselect->conditions = addtolist(" (", nselect->conditions, 'E');

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  attribute_list 
Purpose:
  To add an attribute to a list of attributes and return a structure 
  containing this list.

Parameters:
  identifier        The attribute to add to the list.
  sublist           The sublist of attributes.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* attribute_list(char* variable, SELECTSTMT* sublist)
{
  if(debug_mode) printf("\nIn attribute_list(): variable: %s. ", variable);

  /*
    Pointer for the new statement that will contain the updated attribute 
    list.
  */
  SELECTSTMT* nselect = NULL;

  //Allocate memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  /*
    Add a comma to the existing attribute list and assign it to the new 
    statement (if the attribute list exists).
  */
  if (sublist != NULL)
  {
    nselect->attributes = addtolist(", ", sublist->attributes, 'E');
  }

  //Add new attribute to list.
  nselect->attributes = addtolist(variable, nselect->attributes, 'I');
  
  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  attribute_list_agg 
Purpose:
  To add an attribute to a list of attributes and return a structure 
  containing this list.

Parameters:
  invariable        The attribute to add to the list.
  sublist           The sublist of attributes.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* attribute_list_agg(SELECTSTMT* invariable, SELECTSTMT* sublist)
{
  if(debug_mode) printf("\nIn attribute_list_agg(). ");
  
  /*
    Pointer for the new statement that will hold the attributes for an 
    aggregate statement.
  */
  SELECTSTMT* nselect = NULL;
  
  //Pointer to the variable stored in the invariable structure.
  char* variable = NULL;

  //Allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Assign variable
  variable = invariable->info;

  /*
    Add comma to existing attribute list (if exists) and assign it to new 
    statement.
  */
  if (sublist != NULL)
  {
    nselect->attributes = addtolist(", ", sublist->attributes, 'E');
  }

  /*
    Add the variable to the attribute list and assign the updated list to 
    the new select statement's attribute list.
  */
  nselect->attributes = addtolist(variable, nselect->attributes, 'I');
  
  //Return the new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  operand_list 
Purpose:
  To add an operand to a list and return a structure containing this list.

Parameters:
  operand           The operand to add to the list.
  f_id              Flag that is equal to I if the operand is an id or equal 
                    to E if the operand is a constant.

Returns:
  Pointer to the structure containing the list of operands.
------------------------------------------------------------------------------ */
SELECTSTMT* operand_list(char* operand, char f_id)
{
  if(debug_mode) printf("\nIn operand_list(). ");

  //Pointer to the SELECTSTMT that will hold the list of operands.
  SELECTSTMT* nselect = NULL;

  //Allocate memory for the new SELECTSTMT.
	if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
	{
		fprintf(stderr, "Not enough memory to allocate to list!");
		exit(1);
	}

  //Add operands to list and assign resulting list to conditions list.
	nselect->conditions = addtolist(operand, nselect->conditions, f_id);

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  describestatement 
Purpose:
  To display the schema of the specified table.

Parameters:
  tablename         Name of the table.

Returns:
	None.
------------------------------------------------------------------------------ */
void describestatement(char *tablename)
{
  if(debug_mode) printf("\nIn describestatement(). ");

  //Array used to store the SQL statement used to generate a result describing the table.
	char newsqlstmt[MAXSTMTLENGTH];

  //Copy the majority of the SQL statement.
	strncpy(newsqlstmt, "select column_name, nullable, data_type, data_length, data_precision, data_scale from user_tab_columns where table_name = '", MAXSTMTLENGTH);

  //Convert the table name to uppercase.
	uppercase(tablename);

  //Copy the table name and the closing apostrophy.
	strcat(newsqlstmt, tablename);
  strcat(newsqlstmt, "'");

  //Execute the constructed SQL statement.
	executesqlstmt(newsqlstmt, 'Y', 0);
}



/*----------------------------------------------------------------------------
Function name:
  buildselectstmt 
Purpose:
  To build the select statement string for the select statement in the 
  sqlstmt structure.

Parameters:
  newsqlstmt        string the sql statement is to be put in.
  sqlstmt           structure containing the sql statement.

Returns:
  None.
------------------------------------------------------------------------------ */
void buildselectstmt(char* newsqlstmt, SELECTSTMT* sqlstmt)
{
  if(debug_mode) printf("\nIn buildselectstmt(). ");

  //Start SQL statement with SELECT.
  strncpy(newsqlstmt, "SELECT ", MAXSTMTLENGTH);

  //If join, add star as attribute.
  if (join_flag == 1)
  {
    strcat(newsqlstmt, "* ");
    join_flag = 0;
  }
  else 
  {
    //Add DISTINCT keyword and attributes if attributes present.
    if (sqlstmt->attributes != NULL)
    {
      strcat(newsqlstmt, "DISTINCT ");
      createstring(newsqlstmt, sqlstmt->attributes->front);
    }
    else
    {
      //Add star is no attributes specified.
      strcat(newsqlstmt, "* ");
    }
  }

  //Add FROM keyword and the tables.
  strcat(newsqlstmt, "\n  FROM ");
  createstring(newsqlstmt, sqlstmt->tables->front);
	
  //If conditions are present, add WHERE keyword and the conditions.
  if (sqlstmt->conditions != NULL)
  {
    strcat(newsqlstmt, "\n WHERE ");
    createstring(newsqlstmt, sqlstmt->conditions->front);
  }

  if(debug_mode) printf("\nIn buildselectstmt() method: %s", newsqlstmt);
	
  //If groupby is present, add GROUP BY keywords and portion.
  if (sqlstmt->groupby != NULL)
  {
    strcat(newsqlstmt, "\n GROUP BY ");
    createstring(newsqlstmt, sqlstmt->groupby->front);
  }
}



/*----------------------------------------------------------------------------
Function name:
  executesql 
Purpose:
  To execute the sql statement in the sqlstmt structure.

Parameters:
  sqlstmt           structure containing the sql statement
                    to execute.

Returns:
	None.
------------------------------------------------------------------------------ */
void executesql(SELECTSTMT* sqlstmt)
{
  if(debug_mode) printf("\nIn executesql(). ");

  //Array used to construct the SQL statement for the SELECTSTMT structure.
  char newsqlstmt[MAXSTMTLENGTH];
  
  
  //Pointer used to iterate through the table list.
  LIST_ITEM *current = NULL;
  

  //Testing block.
  /*
          LIST_ITEM* tmp_item = NULL;
          if (sqlstmt->orderby != NULL)
          {
            tmp_item = sqlstmt->orderby->front;
            while (tmp_item != NULL)
            {
              printf("\n In executesql(): tmp_item->id is : %s , tmp_item->typr is : %c", tmp_item->id, tmp_item->type);
              tmp_item = tmp_item->next;
            }
            printf("\n\n");
          }
  */

  /*
    Execute the statement if it does not contain an error.
    Otherwise display the error message.
  */
  if (sqlstmt->f_error != 'E')
  {
    /*
      Change attribute list to '*' if type of outer join operation
      Handle each case for each outer join operation
    */
    current = sqlstmt->tables->front;
    while(current != NULL)
    {
      //NATURAL LEFT OUTER JOIN
      if (strcmp(current->id, " natural left outer join ") == 0)
      {
        sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
        break;
      }
      //NATURAL RIGHT OUTER JOIN
      else if (strcmp(current->id, " natural right outer join ") == 0)
      {
	      sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
	      break;
      }
      //NATURAL FULL OUTER JOIN
      else if (strcmp(current->id, " natural full outer join ") == 0)
      {
	      sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
	      break;
      }
      //LEFT OUTER JOIN
      if (strcmp(current->id, " left outer join ") == 0)
      {
        sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
        break;
      }
      //RIGHT OUTER JOIN
      else if (strcmp(current->id, " right outer join ") == 0)
      {
	      sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
	      break;
      }
      //FULL OUTER JOIN
      else if (strcmp(current->id, " full outer join ") == 0)
      {
	      sqlstmt->attributes = NULL;
        sqlstmt->attributes = addtoback("*", sqlstmt->attributes, 'I');
	      break;
      }
      //Iterate
      current = current->next;
    }
    
    //Build the SQL statement and store it in newsqlstmt.
    buildSqlStmt(newsqlstmt, sqlstmt);

    if(debug_mode) printf("\nIn executesql():\n\n%s\n",newsqlstmt);
    
    //Execute built statement.
    executesqlstmt(newsqlstmt, 'Y', 0);
  }
  else
  {
    if(debug_mode) printf("\nIn executesql(): IN -else branch");
    fprintf(yyout, "\n%s", sqlstmt->errormsg);
  }

  //Free the original sqlstmt.
  freeexpr(sqlstmt);
}



/*----------------------------------------------------------------------------
Function name:
  addtolist 
Purpose:
  To add an entry to the front of a linked list.

Parameters:
  newelement        string to be added to the linked list.
  list              Pointer to the linked list structure to add the element 
                    to.
  f_id              Flag that specifies whether the newelement is to be added 
                    as an id or an element.
Returns:
  LIST.
------------------------------------------------------------------------------ */
LIST* addtolist(char* newelement, LIST* list, char f_id)
{
  if(debug_mode) printf("\nIn addtolist(). ");

  //Pointer to the LIST_ITEM allocated for the element to be added.
	LIST_ITEM* entry = NULL;


  //Allocate memory to the list structure if it is NULL.
	if (list == NULL)
	{
	 	list= NULL;	
		if ((list = (LIST*) calloc(1, sizeof(LIST))) == NULL)
		{
			fprintf(stderr, "Not enough memory to allocate to list!");
			exit(1);
		}
    else
    {
      list->back = NULL;
      list->front = NULL;
      list->count = 0;
    }
  }

  //Allocate memory to the new item.
	if ((entry = (LIST_ITEM *)malloc (sizeof (LIST_ITEM))) == NULL)
  {
		fprintf(stderr, "Not enough memory to add item to list!\n");
    exit(1);
	}
  else{
    entry->prev = NULL;
    entry->next = NULL;
  }

	/*
    Adjust the pointers to add the element to the front of the list,
	  copy the string into the new element, and increase the count of the number
    of elements in the list.
  */
	if (list->front == NULL)
  {
		list->back  = entry;
  }

  //Old Implementation
  /*
        if ((f_id == 'I') || (f_id == 'T') || (f_id == 'N'))
        {
          strncpy(entry->id, newelement, MAXLENGTH);
        }
  */

  //Copy entry if it is an element, table, or comma.
  //X is not used anywhere else in the program.
  if ((f_id == 'I') || (f_id == 'T') || (f_id == 'N') || (f_id == 'E') ||(f_id == 'X'))
	{
		strncpy(entry->id, newelement, MAXLENGTH);
	}
	
  //If the element to be added was an attribute, iterate the attribute count.
  if (f_id == 'I')
  {
    ++list->count;
  }
  //Add element details.
	entry->type = f_id;
	entry->next = list->front;
  
  //If the front of the list isn't empty.
  if (list->front !=NULL)
  {
    list->front->prev = entry;
  }

  //Add the element as the first attribute.
	list->front = entry;
	
  //Return updated list.
	return list;
}



/*----------------------------------------------------------------------------
Function name: 
  addtoback 
Purpose:
	To add an entry to the back of a linked list.

Parameters:
	newelement	      string to be added to the linked list.
	list              Pointer to the linked list structure.
	idFlag		        Flag that specifies whether the new element is to be 
                    added as an id or an element.

Returns:
  The new list containing the newly added element.
------------------------------------------------------------------------------ */
LIST* addtoback(char* newelement, LIST* list, char idFlag)
{
  if(debug_mode) printf("\nIn addtoback(). ");

  //Pointer to the entry to add to the list.
  LIST_ITEM* entry = NULL;

  //Allocate memory to the list structure if it is NULL.
  if (list == NULL)
  {
    list = (LIST*) malloc(sizeof(LIST));
    if (list == NULL)
    {
      fprintf(stderr, "Not enough memory to allocate to list!");
      exit(1);
    }
    else
    {
      list->back = NULL;
      list->front = NULL;
      list->count = 0;
    }
  }

  //Allocate memory to the new item.
  if ((entry = (LIST_ITEM *)malloc (sizeof (LIST_ITEM))) == NULL)
  {
    fprintf(stderr, "Not enough memory to add item to list!\n");
    exit(1);
  }

  /* 
    Adjust the pointers to add the element to the front of the list,
    copy the string into the new element, and increase the count of
    the number of elements in the list.
  */
  if(list->back == NULL)
  {
    list->front = entry;
  }

  //If the element is a valid type (element, table, comma).
  if (idFlag == 'I' || idFlag == 'T' || idFlag == 'N' || idFlag == 'E')
  {
    strncpy(entry->id, newelement, MAXLENGTH);
  }
        
  if (idFlag == 'I')
  {
    ++list->count;
  }

  //Initialize entry details.
  entry->type = idFlag;
  entry->prev = list->back;
  entry->next = NULL;

  //If the list has an element at the back.
  if (list->back !=NULL)
  {
    list->back->next = entry;
  }
  list->back = entry;

  //Return the updated list.
  return list;
}


 
/*----------------------------------------------------------------------------
Function name:
  removeFromBack 
Purpose:
	To remove an entry which is duplicated from the back of a linked list.

Parameters:
  element           string to be removed from the linked list.
	list              Pointer to the linked list structure.

Returns:
  The new list without the element at the back.
------------------------------------------------------------------------------ */
void removeFromBack(char* element, LIST* list)
{
  if(debug_mode) printf("\nIn removeFromBack(). ");

  //Pointer used to iterate through the list from the back.
  LIST_ITEM* backward;
  
  //Pointer used to iterate through the list from the front.
  LIST_ITEM* forward;
  
  //Integer variable used to indicate whether the element was found.
  int found;
  
  //Integer variable used to store the position of the dot operator.
  int dot_position;
  
  /*
    Array used to temporarily store the string past the dot operator.
    (The actual attribute)
  */
  char tempstr[MAXLENGTH];


  //If the list is empty, return.
  if (list == NULL)
  {
    return;
  }

  //Assign dot operator position.
  dot_position = strsearch(element, '.');
  //If dot operator not found, return.
  if (dot_position < 0)
  {
    return;
  }

  //Assign attribute value.
  strcpy(tempstr, element+dot_position);
  if(debug_mode) printf("\nAttribute name:\n%s\n", tempstr);

  //Search backward.
  backward = list->back;

  //Reset found flag.
  found = 0;

  //Iterate through the list from the back.
  while(found == 0 && backward != NULL)
  {
    //Assign dot position for current element.
    dot_position = strsearch(backward->id, '.');
    //If dot was present.
    if (dot_position > 0)
    {
      //Compare to element you are trying to find.
      if (strcmp(tempstr, backward->id+dot_position) == 0)
      {
        found = 1;
      }
      else
      {
        backward = backward->prev;
      }
    }
    else
    {
      backward = backward->prev;
    }
  }

  //Not found, so exit.
  if (found == 0)
  {
    return;
  }

  //Search forward.
  forward = list->front;
  //Reset found flag.
  found = 0;

  //Iterate through the list from the front.
  while(found == 0 && forward != NULL)
  {
    dot_position = strsearch(forward->id, '.');
    if (dot_position > 0)
    {
      //If the current attribute is the same as the element, flip flag.
      if (strcmp(tempstr, forward->id+dot_position) == 0)
      {
        found = 1;
      }
      else
      {
        forward = forward->next;
      }
    }
    else
    {
      forward = forward->next;
    }
  }

  //Check if only one match.
  if (backward == forward)
  {
    return;
  }

  //Remove the last match node and and a comma node before it.
  if (backward->prev != NULL)
  {
    backward->prev->prev->next = backward->next;
  }

  if (backward->next != NULL)
  {
    backward->next->prev = backward->prev->prev;
  }

  //Free the memory for the LIST_ITEM used for the comma.
  free(backward->prev);
  //Free the memory for the LIST_ITEM used for the backward element.
  free(backward);
  //Decrement the amount of items in the list.
  --list->count;

  //Return to calling method.
  return;
}


 
/*----------------------------------------------------------------------------
Function name:
  mergelist 
Purpose:
  To merge two linked lists.

Parameters:
  list1             List to be at the front of the new list.
	list2             List to be at the back of the merged list.

Returns:
	A pointer to a merged list.
------------------------------------------------------------------------------ */
LIST* mergelist(LIST* list1, LIST* list2)
{
  if(debug_mode) printf("\nIn mergelist(). ");

  //If the first list is empty, return the second list.
  if(list1 == NULL)
  {
    return list2;
  }
  
  //If the second list is empty, return first list.
  if(list2 == NULL)
  {
    return list1;
  }

  /*
    Only if the first list is not the second list, merge the lists.
    Add the second list to the back of the first list.
  */
  if(list1 != list2)
  {
	  list1->back->next = list2->front;
	  list2->front->prev = list1->back;
	  list1->back = list2->back;
  }
  
  //Return the merged list.
  return list1;
}



/*----------------------------------------------------------------------------
Function name:
  searchlist 
Purpose:
  To search the linked list for element.

Parameters:
  element           The element to be searched for.
  front		          The front of the list to be searched.

Returns:
	0       Upon not finding element.
	1 	    Upon finding element.
------------------------------------------------------------------------------ */
int searchlist(char* element, LIST_ITEM* front)
{
  if(debug_mode)
  {
    printf("\nIn searchlist(). ");
  }

  //Integer variable used to store the length of the element to be searched.
  int length;
  
  //Pointer used to iterate through the list.
  LIST_ITEM* current = front;
  
  //string to be used to search through the list. (Formatted without prefix)
  char searchstring[MAXLENGTH];
  
  //Formatted current attribute without table prefix.
  char currentstring[MAXLENGTH];

  //Parse the element to not have a prefix.
  parse_attribute(element, searchstring);

  //If the current attribute is an element or a table.
  if ((current->type == 'I') || (current->type == 'N') || (current->type == 'T'))
  {
    parse_attribute(current->id, currentstring);
  }

  //Assign element length to length.
  length = strlen(searchstring);

  /*
    Loop through the linked list and search for the string in element.
  */
  while ((current != NULL) && (strncmp(searchstring, currentstring, length) != 0))
  {
    //Iterate
    current = current->next;
    /*
      If the current attribute is an element or table, parse the current 
      attribute.
    */
    if ((current != NULL) && ((current->type == 'I') || (current->type == 'N') || (current->type == 'T')))
    {
      parse_attribute(current->id, currentstring);		
    }
  }


  //Return 0 if not found or 1 if found.
  if (current == NULL)
  {
    return 0;
  }
  else
  {
    return 1;
  }
}



/*----------------------------------------------------------------------------
Function name:
  compare_lists 
Purpose:
  To compare two linked lists to see if they have the same elements.

Parameters:
  list1             First list to be compared.
	list2             Second list to be compared.
	errormsg	        string to store error messages in.

Returns:
	Error char that is C if the lists are the same or E if they are not.
------------------------------------------------------------------------------ */
char compare_lists(LIST* list1, LIST* list2, char* errormsg)
{
  if(debug_mode) printf("\nIn compare_lists(). ");

  //Pointer used to iterate through the first list.
  LIST_ITEM* current = list1->front;

  /*
    If the amount of elements in the first list does not match the amount of
    elements in the second list, throw an error.
  */
  if (list1->count != list2->count)
  {
    strncpy(errormsg, "Number of attributes in the two subexpressions do not equal ", MAXERRMSGLENGTH);
    return 'E';
  }
  else
  {
    /*
      If both lists have the same amount of elements, then iterate through 
      the first list, and should there be an element in the first list that
      cannot be found in the second list, throw an error.
    */
    while (current != NULL)
    {
      if ((current->type == 'I') && (searchlist(current->id, list2->front) != 1))
      {
        strncpy(errormsg, "The same attributes are not in both subexpressions ", MAXERRMSGLENGTH);
        return 'E';
      }
      //Iterate.
      current = current->next;
    }
  }

  //Return cleared status.
  return 'C';
}



/*----------------------------------------------------------------------------
Function name:
  addtablename 
Purpose:
  To add tablename to the front of the attributes in the LIST pointed to by 
  front.

Parameters:
  tablename	        The tablename to add to the front of attributes.
	front             The front of the list of attributes.
  errormsg	        The string to store error messages in.

Returns:
  Error char equal to E if the attribute is not in tablename or if the new 
  attribute name is already in tablename and equal to C if all attributes are 
  in the table.
------------------------------------------------------------------------------ */
char addtablename(char* tablename, LIST_ITEM* front, char* errormsg)
{
  if(debug_mode) printf("\nIn addtablename(). ");

  //Pointer used to iterate through the list.
	LIST_ITEM *current = front;
  
  //Integer variable used to indicate if the string was found within the list.
  int searchresult;
	
  //Array used to construct an attribute containing a table prefix.
  char tabledot[MAXLENGTH];
  
  //Pointer to list containing the column names of table tablename.
  LIST *table_columns = retrieve_column_names(tablename);
  
  //Convert tablename to lowercase.
  lowercase(tablename);

	/* 
    Loop through the list of attributes adding tablename to the front of the
    attribute string.
  */
	while (current != NULL)
	{
    //If element.
		if ((current->type == 'I') || (current->type == 'N'))
		{
      //Convert current attribute to uppercase.
			uppercase(current->id);

      //Search table columns list for current attribute.
			searchresult = searchlist(current->id, table_columns->front);

      /*
        If the attribute was found within the list, then create a string
        containing a table prefix and the attribute and assign that string
        to be the current attribute's id value.
      */
			if ((searchresult == 1) && (current->type == 'I'))
      {
				strncpy(tabledot, tablename, MAXLENGTH);
				strcat(tabledot, ".");
				strcat(tabledot, current->id);
				strncpy(current->id, tabledot, MAXLENGTH);
			}
      //Otherwise, throw error.
			else if ((searchresult == 1) && (current->type == 'N'))
			{
				strncpy(errormsg, "Column name ", MAXERRMSGLENGTH);
				strcat(errormsg, current->id);
				strcat(errormsg, " already exists in table ");
				strcat(errormsg, tablename);
        freelist(table_columns);
				return 'E';
			}
			else if ((searchresult != 1) && (current->type == 'I'))
      {
				strncpy(errormsg, "Invalid column name ", MAXERRMSGLENGTH);
				strncat(errormsg, current->id, MAXLENGTH);
        freelist(table_columns);
				return 'E';
      }
		}

    //Iterate.
    current = current->next;
	}

  //Free the memory used by the list of column names.
	freelist(table_columns);
	
  //Return cleared status.
  return 'C';
}



/*----------------------------------------------------------------------------
Function name:
  addptablename 
Purpose:
  To add the tablename to the front of an attribute that is found in the 
  attributes of a SUBEXPRESSION.

Parameters:
  nfront            The front of the list of new attributes to add table 
                    names to.
  ofront            The front of the list of attributes in the subexpression.
  errormsg	        The string to put error messages into.

Returns:
  Error char equal to E if the attribute is not in subexpression or if the 
  new attribute name is already in subexpression and equal to C if all 
  attributes are in the subexpression.
------------------------------------------------------------------------------ */
char addptablename(LIST_ITEM* nfront, LIST_ITEM* ofront, char* errormsg)
{
  if(debug_mode) printf("\nIn addptablename(). ");

  //Used to iterate through the list of column names
	LIST_ITEM *ncurrent = nfront;
  
  //Used to iterate through the list of attributes
  LIST_ITEM *ocurrent = ofront;

	/* 
    Loop through the list of attributes adding the tablename to
	  the front of the attribute string.
  */
	while (ncurrent != NULL)
	{   
    //If element.
		if ((ncurrent->type == 'I') || (ncurrent->type == 'N'))
		{
      //Convert id to uppercase.
			uppercase(ncurrent->id);
      
      //While ncurrent cannot be found within ocurrent, iterate.
			while ((ocurrent != NULL) && (strstr(ocurrent->id, ncurrent->id) == NULL))
			{
        ocurrent = ocurrent->next;
			}
                                		
      /*
        If ncurrent was found within ocurrent and it is an element,
        copy ocurrent into ncurrent's id.
      */
			if ((ocurrent != NULL) && (ncurrent->type == 'I'))
      {
        strncpy(ncurrent->id, ocurrent->id, MAXLENGTH);
      }
      /*
        Otherwise, throw error.
      */
			else if ((ocurrent != NULL) && (ncurrent->type == 'N'))
			{
				strncpy(errormsg, "In addptablename()--Column name ", MAXERRMSGLENGTH);
				strcat(errormsg, ncurrent->id);
				strcat(errormsg, "already exists in subexpression ");
				return 'E';
			}
			else if ((ocurrent == NULL) && (ncurrent->type == 'I'))
      {
        strncpy(errormsg, "In addptablename()--Invalid column name ", MAXERRMSGLENGTH);
				strcat(errormsg, ncurrent->id);
				return 'E';
			}

      //Reset ocurrent to the front of the attribute list.
			ocurrent = ofront;
		}

    //Iterate.
		ncurrent = ncurrent->next;
	}

  //Return cleared status.
	return 'C';
}



/*----------------------------------------------------------------------------
Function name:
  addattributes 
Purpose:
  To retrieve all of the attributes in the table tablename and add these to 
  the select statement in subexpr.

Parameters:
  tablename	        The name of the table.
  subexpr           The select statement structure to add the attributes to.

Returns:
  None.
------------------------------------------------------------------------------ */
void addattributes(char* tablename, SELECTSTMT* subexpr)
{
  if(debug_mode) printf("\nIn addattributes(). ");

  //Pointer used to iterate through the retrieved table columns.
	LIST_ITEM* current = NULL;
	
  /*
    Array used to create attributes that contain a table prefix with 
    tablename.
  */
  char tabledot[MAXLENGTH];
	
  //Integer variable used to store the length of the current attribute.
  int length;
  
  /*
    Pointer used to store a reference to the list containing the column 
    names.
  */
  LIST* table_columns = retrieve_column_names(tablename);
  
  //Conver the table name to lowercase.
  lowercase(tablename);
	
	/*
    Loop through the list of retrieved columns
	  adding each of the attributes to the select statement.
  */
  current = table_columns->front;
	while (current != NULL)
	{
		strncpy(tabledot, tablename, MAXLENGTH);
		strcat(tabledot, ".");
		length = strcspn(current->id, " ");
		strncat(tabledot, current->id, length);
    subexpr->attributes = addtoback(tabledot, subexpr->attributes, 'I');
		//Add a comma between attributes if another attribute exists.
    if (current->next != NULL)
    {
	    subexpr->attributes = addtoback(", ", subexpr->attributes, 'E');
    }
		//Iterate.
		current = current->next;
	}

  //Free the memory occupied by the list of table columns.
	freelist(table_columns);
}



/*----------------------------------------------------------------------------
Function name:
  retrieve_column_names 
Purpose:
  To retrieve all of the columns in tablename and return them in a linked 
  list.

Parameters:
	tablename         The name of the table to retrieve the columns for.

Returns:
  Linked list containing the attributes of the table.
------------------------------------------------------------------------------ */
LIST* retrieve_column_names(char* tablename)
{
  if(debug_mode) printf("\nIn retrieve_column_names(). ");

  //Array used to build the new SQL statement.
	char newsqlstmt[MAXSTMTLENGTH];
  newsqlstmt[0] = '\0';
	
  //Pointer to the resulting columns from a query.
  LIST* colum = NULL;
  
  //Convert the tablename to uppercase.
  uppercase(tablename);

  //Create the new statement.
	strncpy(newsqlstmt, "select column_name from user_tab_columns where table_name = '", MAXSTMTLENGTH);
	strcat(newsqlstmt, tablename);
	strcat(newsqlstmt, "'");
  
  //Execute statement and store result in colum.
	colum = executesqlstmt(newsqlstmt, 'N', 0);
  
  //Return result.
  return colum;
}



/*----------------------------------------------------------------------------
Function name:
  createstring 
Purpose:
  To loop through all of the elements in a linked list and concatenate them 
  into the string sqlstring.

Parameters:
	sqlstring         The string to place the elements into.
	front             The front of the list containing the elements.

Returns:
  None.
------------------------------------------------------------------------------ */
void createstring(char* sqlstring, LIST_ITEM* front)
{
  if(debug_mode) printf("\nIn createstring(). ");

  //Pointer used to iterate through the list.
	LIST_ITEM* current = front;

  //Iterate through the list, and add each element of the list to sqlstring.
	while (current != NULL)
	{
		if ((current->type == 'I') || (current->type == 'N') || (current->type == 'T') || (current->type == 'E'))
			strcat(sqlstring, current->id);
    //Iterate.
		current = current->next;
	}
}



/*----------------------------------------------------------------------------
Function name:
  parse_attribute 
Purpose:
  To remove the attribute name from a string that contains the table name 
  followed by the attribute name.

Parameters:
  tabatt            The string containing the tablename followed by the 
                    attribute separated by a dot
  attribute         The string to place the retrieved attribute into.

Returns:
  None.
------------------------------------------------------------------------------ */
void parse_attribute(char *tabatt, char *attribute)
{
  if(debug_mode) printf("\nIn parse_attribute(). ");

  //Pointer to a string without the table prefix.
  char* foundstring = NULL;

  //Array to temporarily store the attribute string.
  char tempstring[MAXLENGTH];

  //Copy the attribute string
  strncpy(tempstring, tabatt, MAXLENGTH);

  //Store the fix token preceding the prefix operator.
  foundstring = strtok(tempstring, ".");	
  if ((foundstring = strtok(NULL, ".")) != NULL)
  {
    //Copy into attribute if second token not NULL.
    strncpy(attribute, foundstring, MAXLENGTH);
  }
  else
  {
    //Else copy into attribute the original attribute.
    strncpy(attribute, tabatt, MAXLENGTH);
  }
}



/*----------------------------------------------------------------------------
Function name:
  uppercase 
Purpose:
  To change a string into uppercase.

Parameters:
  string            The string to change to uppercase.

Returns:
  None.
------------------------------------------------------------------------------ */
void uppercase(char* string)
{
  if(debug_mode) printf("\nIn uppercase(). ");

  //Integer variable used to iterate through the string.
  int i;
  
  /*
    Integer variable used to keep track of the string's length.
  */
  int length;

  //Assign string length to length.
  length = strlen(string);
     
  //Iterate through string and convert characters to uppercase. 
  for (i=0; i < length; i++)
  {
    string[i] = toupper(string[i]);
  }
}



/*----------------------------------------------------------------------------
Function name:
  lowercase 
Purpose:
  To change a string into uppercase.

Parameters:
  string            The string to change to uppercase.

Returns:
  None.
------------------------------------------------------------------------------ */
void lowercase(char* string)
{
  if(debug_mode) printf("\nIn lowercase(). ");

  //Integer variable used to iterate through the string.
  int i; 
  
  /*
    Integer variable used to keep track of the string's length.
  */
  int length;

  //Assign string length to length.
  length = strlen(string);

  //Iterate through string and convert characters to lowercase.
  for (i=0; i < length; i++)
  {
    string[i] = tolower(string[i]);
  }
}



/*----------------------------------------------------------------------------
Function name:
  retrieveattribute 
Purpose:
  To retrieve elements in the attributes list without their table prefixes.

Parameters:
  table_name        The table from which we would like to retrieve its 
                    attributes without their table prefixes.

Returns:
  A structure containing the attributes and table names.
------------------------------------------------------------------------------ */
SELECTSTMT* retrieveattribute(char* table_name)
{
  if(debug_mode) printf("\nIn retrieveattribute(). ");

  /*
    Pointer to the new statement that will contain the attribute list without
    their prefixes.
  */
  SELECTSTMT* nselect = NULL;
  
  //Pointer to the list of attributes of the original table.
  LIST* tab1_columns = NULL;
  
  //Pointer used to iterate through the list of table attributes.
  LIST_ITEM* ncurrent = NULL;
  
  /*
    Array used to temporarily store the current column name without its 
    table prefix.
  */
  char temp_str[MAXLENGTH];
  
  //Integer variable used to hold the length of the current attribute.
  int length;

  //Allocate memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //If the list of columns in the table is not empty.
  if ((tab1_columns = (LIST*) retrieve_column_names(table_name)) != NULL)
  {
    /*
      Iterate through the column list without prefixes and add them to the 
      new statement.
    */
    ncurrent = tab1_columns->front;
    while(ncurrent != NULL)
    {
      temp_str[0] = '\0';
      length = strcspn(ncurrent->id, " ");
      strncpy(temp_str, ncurrent->id, length);
     
      temp_str[length] = '\0';
      nselect->attributes = addtoback(temp_str, nselect->attributes, 'I');
     
      //If there is another attribute in the list, add a comma.
      if(ncurrent->next != NULL)
      {
        nselect->attributes = addtoback(" ,", nselect->attributes, 'E');
      }
      ncurrent = ncurrent->next;
    }

    /*
      Add the table name to the table list of the new statement.
      Add the error status to cleared for the new statement.
    */
    nselect->tables = addtoback(table_name, nselect->tables, 'T');
    nselect->f_error = 'C';
  }

  //Return the new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  findattribute 
Purpose:
  To find the attributes in the temp_tbl_name1 that are not present in
  temp_tbl_name2.

Parameters:
  temp_tbl_name1    The first table from which we would want to know which 
                    attributes are not present in the second table.
  temp_tbl_name2    The second table used to determine which attributes are 
                    present in the first table, but not the second.

Returns:
  A pointer to a new (formatted) statement containing the attributes present 
  in the first table, but not the second table.
------------------------------------------------------------------------------ */
SELECTSTMT* findattribute(char* temp_tbl_name1, char* temp_tbl_name2)
{
  if(debug_mode) printf("\nIn findattribute(). ");
  
  /*
    Pointer to a newly created statement that will contain the existing 
    attributes of the first table, and the attributes not in common with
    the second table.
  */
  SELECTSTMT* nselect = NULL; 
  
  /*
    Formatted version of nselect with the attribute list separated by commas.
  */
  SELECTSTMT* nselect_1 = NULL;
  
  //Pointer to list containing the columns of the first table.
  LIST* tab1_columns = NULL;
  
  //Pointer to list containing the columsn of the second table.
  LIST* tab2_columns = NULL;
  
  //Pointer used to iterate through the first table's columns.
  LIST_ITEM* ncurrent = NULL;
  
  /*
    Array used to temporarily store the contents of the current element's id.
  */
  char temp_str[MAXLENGTH];
  
  //Integer variable keeping track of the length of the current attribute.
  int length;

  //Allocate memory for the first new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Allocate memory for the second new statement.
  if ((nselect_1 = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Find projected attributes.
  if ((tab1_columns = (LIST*) retrieve_column_names(temp_tbl_name1)) != NULL
       && (tab2_columns = (LIST*) retrieve_column_names(temp_tbl_name2)) != NULL)
  {
    ncurrent = tab1_columns->front;
   
    /*
      Loop through the attribute list for the first table and determine if it
      can be found in the second table. Add the attributes that cannot be found
      in the second table to the attribute list of the new statement.
    */
    while (ncurrent != NULL)
    {
      temp_str[0] = '\0';
      if(ncurrent->type == 'I')
      {
        if(searchlist(ncurrent->id, tab2_columns->front) != 1)
        {
          length = strcspn(ncurrent->id, " ");
          strncpy(temp_str, ncurrent->id, length);
          temp_str[length] = '\0';
          nselect->attributes = addtoback(temp_str, nselect->attributes, 'I');
        }
      }
      ncurrent = ncurrent->next;
    }

    /*
      Iterate trhough the attribute list of the new statement and format it
      by adding commas between each attribute.
    */
    ncurrent = nselect->attributes->front;
    while (ncurrent != NULL)
    {
      nselect_1->attributes = addtoback(ncurrent->id, nselect_1->attributes, 'I');
      if(ncurrent->next != NULL)
        nselect_1->attributes = addtoback(", ", nselect_1->attributes, 'E');
      ncurrent = ncurrent->next;
    }
    /*
      Add the first table's name to the table list of the new statement.
      Add the error status to cleared for the new statement.
    */
    nselect_1->tables = addtoback(temp_tbl_name1, nselect_1->tables, 'T');
    nselect_1->f_error = 'C';
  }
  
  //Free the memory for the first new statement.
  freeexpr(nselect);

  //Return the pointer to the second (formatted) new statement.
  return nselect_1;
}



/*----------------------------------------------------------------------------
Function name:
  propersubset 
Purpose:
  To check if the attributes in the temp_tbl_name2 is a propersubset of these attributes
  belong the attributes in the temp_tbl_name2.

Parameters:
  temp_tbl_name1    Table name of the first table to check if some of its
                    attributes form a proper set in temp_tbl_name2.
  temp_tbl_name2    Table name of the second table from which we would like 
                    to check if its attributes form a proper subset of 
                    temp_tbl_name1.

Returns:
  1       If the second table does form a proper subset of the first table.
  0       If the second table does not form a proper subset of the first table.
------------------------------------------------------------------------------ */
int propersubset(char* temp_tbl_name1, char* temp_tbl_name2)
{
  if(debug_mode) printf("\nIn propersubset(). ");
  
  /*
    Integer indicating if the second table forms a proper subset of the 
    first table.
  */
  int result = 0;
  
  //Pointer to the list of columns from the first table.
  LIST *tab1_columns = NULL; 
  
  //Pointer to the list of columns from the second table.
  LIST *tab2_columns = NULL;
  
  /*
    Pointer used to iterate through the columns of the second table to be 
    used to search through the columns of the first table to determine if 
    it is a proper subset.
  */
  LIST_ITEM* ncurrent = NULL;


  //Find projected attributes
  if ((tab1_columns = (LIST*) retrieve_column_names(temp_tbl_name1)) != NULL
       && (tab2_columns = (LIST*) retrieve_column_names(temp_tbl_name2)) != NULL)
  {
    ncurrent = tab2_columns->front;
    //Loop through the list of the columns in the second table.
    while (ncurrent != NULL)
    {
      if (ncurrent->type == 'I')
      { 
        //Search the list for the current attribute, and return 0 if no match found.
        if (searchlist(ncurrent->id, tab1_columns->front) != 1)
        {
           return 0; 
        }
	      else
        {
	        result = 1;
        }
      }

      //Iterate through the second list.
      ncurrent = ncurrent->next;
    }
  }
  //Return the result of the comparison.
  return result;
}



/*----------------------------------------------------------------------------
Function name:
  freeexpr 
Purpose:
  To deallocate the memory allocated to a select statement structure.

Parameters:
  expr              The select statement to deallocate memory for.

Returns:
	None.
------------------------------------------------------------------------------ */
void freeexpr(SELECTSTMT* expr)
{
  if(debug_mode) printf("\nIn freeexpr(). ");

  //If the expression is not empty, free the memory of its sublists.
  if (expr != NULL)
  {
    freelist(expr->attributes);
    freelist(expr->tables);
    freelist(expr->conditions);
    freelist(expr->groupby);
  }
}



/*----------------------------------------------------------------------------
Function name:
  freelist 
Purpose:
  To deallocate the memory allocated to an entire linked list.

Parameters:
  list              The list whose elements and memory must be deallocated.

Returns:
	None.
------------------------------------------------------------------------------ */
void freelist(LIST* list)
{	
  if(debug_mode) printf("\nIn freelist(). ");

  //Pointer to the previous element (not NULL) in the list.
	LIST_ITEM* old = NULL;
  
  //Pointer to the current element in the list.
  LIST_ITEM* current = NULL;

  /*
    If the list itself is not null.
  */
	if (list != NULL)
	{
	  /* 
      Loop through the linked list deallocating memory for each element and 
      then the linked list structure itself.
    */
		current = list->front;
    //Iterate through the list.
		while (current != NULL)
		{
      /*
        Assign old pointer to current value of 'current'.
      */
      old = current;
      //Iterate.
			current = current->next;
      /*
        Free memory for the element being pointed to by the 'old' pointer.
      */
      free(old);
		}
    //Free the memory of the list.
		free(list);
  }
}



/*----------------------------------------------------------------------------
Function name:
  strsearch 
Purpose:
  Search a character in a string.

Parameters:
	p_str             A string to be searched for the character.
  p_char            The character to search for within p_str.
Returns:
	position for the first occurence in the string, if found,
  otherwise, -1.
------------------------------------------------------------------------------ */
int strsearch(char* p_str, char p_char)
{
  if(debug_mode) printf("\nIn strsearch(). ");

  //The position within the string to be searched.
  int position;
  
  //If the string is empty, return -1.
  if (p_str[0] == '\0' )
  {
    return -1;
  }
  position = 0;
  /*
    Iterate through the string, and if the character is found return its 
    position.
  */
  while(p_str[position] != '\0')
  {
    if (p_str[position++] == p_char)
    {
      return position;
    }
  }

  //Return a flag indicating the character was not found within the string.
  return -1;
}



/*----------------------------------------------------------------------------
Function name:
  generate_temp_table_name 
Purpose:
  To get a new temporary name that is prefixed by temp and ends in a random 
  number such that the entire name is not already used. 

Parameters:
  p_table_name      string to put the name for the temporary table into.

Returns:
  None.
------------------------------------------------------------------------------ */
void generate_temp_table_name(char* p_table_name)
{
  if(debug_mode) printf("\nIn generate_temp_table_name(). ");

  //Pointer to the new temp table entry to be generated.
  LIST_ITEM* new_list_item = NULL;
  
  //Integer used to iterate and generate a new temporary table name.
  int i;
  
  /* set seed for random number generator */
  if(temp_table_list == NULL)
  {
    srand((unsigned) time(NULL));
  }

  //Initialize a new list item for the new temp table name
  if ((new_list_item = (LIST_ITEM *)malloc (sizeof (LIST_ITEM))) == NULL)
  {
    fprintf(stderr, "Not enough memory to add item to list!\n");
    exit(1);
  }

  //Create a unique temporary table name
  strcpy(p_table_name, "temp");
  for(i=4; i<10; i++)
  {
    p_table_name[i] = (rand() % 10) + 48;
  }
  p_table_name[i] = '\0';

  //Add the temporary table name into temp_table_list
  temp_table_list = addtoback(p_table_name, temp_table_list, 'T');

  if(debug_mode) printf("In generate_temp_table_name(): temp_table_name: %s", p_table_name);
}



/*----------------------------------------------------------------------------
Function name:
  delete_temp_tables 
Purpose:
  To delete the temporary table name that is prefixed by temp and ends in a 
  random number.

Parameters:
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
void delete_temp_tables()
{
  if(debug_mode) printf("\nIn delete_temp_tables(). ");

  //Pointer used to iterate through the temp table list.
  LIST_ITEM* current = NULL;

  /*
    If the temp table list is not empty.
  */
  if (temp_table_list != NULL)
  {
    //Assign initial value of the rename table list.
    current = temp_table_list->front;
    /*
      Loop through the linked list deallocating memory for each element and 
      then the linked list structure itself. 
    */
    while (current != NULL)
    {
      //Drop the temp table.
      dropTmpTables(current->id);
      current = current->next;
    }
  }

  //Free the temp table list.
  freelist(temp_table_list);
  temp_table_list = NULL;
}



/*----------------------------------------------------------------------------
Function name:
  addToRenList 
Purpose:
  To add elements to the rename list.

Parameters:
  id                The name of the intermediary table produced by a rename 
                    operation.

Returns:
  None.
------------------------------------------------------------------------------ */
void addToRenList(char* id)
{
  if(debug_mode) printf("\nIn addToRenList(). ");

  //Add a table to the rename table list.
  ren_table_list = addtoback(id, ren_table_list, 'T');
}



/*----------------------------------------------------------------------------
Function name:
  delete_ren_tables 
Purpose:
  To delete the intermediary tables for rename operations.

Parameters: 
  None.

Returns:
  None.
------------------------------------------------------------------------------ */
void delete_ren_tables()
{
  if(debug_mode) printf("\nIn delete_ren_tables(). ");

  //Pointer used to iterate through the rename table list.
  LIST_ITEM* current = NULL;

  /*
    If the rename table list is not empty.
  */
  if (ren_table_list != NULL)
  {
    //Assign initial value of the rename table list.
    current = ren_table_list->front;
    /*
      Loop through the linked list deallocating memory for each element and 
      then the linked list structure itself.
    */
    while (current != NULL)
    {
      //Drop the rename table.
      dropTmpTables(current->id);
      current = current->next;
    }
  }
  //Free the rename table list.
  freelist(ren_table_list);
  ren_table_list = NULL;
}



/*----------------------------------------------------------------------------
Function name:
  find_duplicated_column 
Purpose:
  To find the duplicated column in the attributes.
  For example: there are more than one same attributes. 

Parameters:
  expression        The structure containing some table, attributes and conditions
                    information.

Returns:
  1       If duplicate found.
  0       If no duplicates were found.
------------------------------------------------------------------------------ */
int find_duplicated_column(SELECTSTMT* expression)
{
  if(debug_mode) printf("\nIn find_duplicated_column(). ");

  //Pointer used to iterate through the attribute list.
  LIST_ITEM* current = NULL;

  /*
    Pointer used to iterate through the attribute list following the current
    attribute used for considering attributes.
  */
  LIST_ITEM* inner_current = NULL;
   
  //Print list of attributes in expression (only if debug mode is active).
  printList_i(expression->attributes);

  //If the attributes list is empty, return 0.
  if(expression->attributes == NULL)
    return 0;

  //Assign the front of the attributes list as the value of the pointer.
  current = expression->attributes->front;
  
  //Iterate through the attributes list.
  while(current)
  {
    //If the current attribute list item is not a space or comma.
    if(strcmp(current->id, ", ") != 0 && strcmp(current->id, " ") != 0)
    {
      /*
        Assign initial value of pointer to be the LIST_ITEM following the 
        current attribute.
      */
      inner_current = current->next;

      //Iterate through the inner loop.
      while(inner_current != NULL)
      {
        //If a duplicate is found for the current attributes, return 1.
        if(strcmp(inner_current->id, ", ") != 0 && strcmp(current->id, " ") != 0)
          if(compare_attribute(current->id, inner_current->id) == 0){
            return 1;
          }

        //Iterate inner loop.
        inner_current = inner_current->next;
      }
    }

    //Iterate outer loop.
    current = current->next;
  }

  //If duplicate never found, return 0.
  return 0;
}



/*----------------------------------------------------------------------------
Function name:
  remove_duplicated_column 
Purpose:
  To find the duplicated attributes in the attributes list. 
  For example: there are more than one same attributes and remove it, but 
  only keep one distinct attributes.

Parameters:
	expression        The structure containing some table, attributes and 
                    conditions information.

Returns:
  1       If duplicate columns were removed.
  0       If duplicate columns were not removed.
------------------------------------------------------------------------------ */
int remove_duplicated_column(SELECTSTMT* expression)
{
  if (debug_mode) printf("\nIn remove_duplicated_column(). ");

  //Pointer to the LIST_ITEM currently being considered for duplicates.
  LIST_ITEM* current = NULL;
  
  /*
    Pointer to the LIST_ITEM current being considered as a duplicate for the 
    'current' LIST_ITEM.
  */
  LIST_ITEM* inner_current = NULL;

  //Print list of attributes in expression (only if debug mode is active).
  printList_i(expression->attributes);

  //If the attributes list is empty, return 0.
  if(expression->attributes == NULL)
    return 0;

  //Set initial value of the current pointer to the front of the list.
  current = expression->attributes->front;
  
  //Iterate through the list of attributes.
  while(current)
  {
    /*
      If the current attribute's id string is a comma.
    */
    if(strcmp(current->id, ", ") != 0 )
    {
      //Assign initial value to be the LIST_ITEM following the current LIST_ITEM attribute.
      inner_current = current->next;
      
      //Iterate through inner loop for duplicates.
      while(inner_current != NULL)
      {
        if(strcmp(inner_current->id, ", ") != 0)
          if(compare_attribute(current->id, inner_current->id) == 0)
          {
            remove_attribute(expression->attributes, inner_current);
            return 1;
          }

        //Iterate for inner loop.
        inner_current = inner_current->next;
      }
    }

    //Iterate for outer loop.
    current = current->next;
  }
  //No duplicates were found. Return 0.
  return 0;
}



/*----------------------------------------------------------------------------
Function name:
  compare_attribute 
Purpose:
  To get the attributes that is following the ".": for example: student.s#
  and sc.c# and compare the s# and c#.

Parameters:
  attribute1        The attribute containing tablename.attribute 
                    (e.g. student.s#).
  attribute2        The attribute containing tablename.attribute 
                    (e.g. student.s#).

Returns:
  0       If the two attribute strings are the same.
  1       If the two attribute strings are not the same. 
------------------------------------------------------------------------------ */
int compare_attribute(char* attribute1, char* attribute2)
{
  if(debug_mode) printf("\nIn compare_attribute(). ");

  //Array used to temporarily store the value of the first attribute.
  char  temp_attr1[MAXLENGTH];
  
  //Array used to temporarily store the value of the second attribute.
  char  temp_attr2[MAXLENGTH];
  
  /*
    Pointer used to point to the token preceding the first occurrence of 
    the open bracket in the first attribute.
  */
  char* sub_str1 = NULL;
  
  /*
    Pointer used to point to the token preceding the first occurrence of 
    the open bracket in the second attribute.
  */
  char* sub_str2 = NULL;

  /*
    If both attributes have a symbol.
  */
  if(find_symbol(attribute1) && find_symbol(attribute2))
  {
    //Copy the attributes to the temporary arrays.
    strncpy(temp_attr1, attribute1, MAXLENGTH);
    strncpy(temp_attr2, attribute2, MAXLENGTH);

    //Assign pointers to the first tokens preceding open brackets.
    sub_str1 = strtok(temp_attr1, "(");
    sub_str2 = strtok(temp_attr2, "(");
    
    /*
      If the substrings are different, return 1 since the attributes
      are different.
    */
    if (strcmp(sub_str1, sub_str2) != 0)
    {
      /* the symbols are different */
      return 1;
    }
  }

  //Parse the attributes for their values after any symbols.
  parse_attribute(attribute1, temp_attr1);
  parse_attribute(attribute2, temp_attr2);

  //Return the result of a comparison between the
  return strcmp(temp_attr1, temp_attr2);
}



/*----------------------------------------------------------------------------
Function name:
  remove_attribute 
Purpose:
  To remove the node which contain the attribute to be deleted and also
  remove the node which contain ", " next to attribute node.

Parameters:
  list              The list containing to be deleted node.
  item              The node to be removed containing ", " and ".attribute".

Returns:
  None.
------------------------------------------------------------------------------ */
void remove_attribute(LIST* list, LIST_ITEM* item)
{
  if(debug_mode) printf("\nIn remove_attribute(). ");

  //Item is the first node in the list.
  if (list->front == item)
  {
    //If list contains more than 1 item.
    if (item->next != NULL)
    {  
      /*
        If the attribute to be removed was part of a multi-attribute list,
        remove the comma following the attribute.
        Else, the comma is missing and there is an error in syntax.
      */
      if (strcmp(item->next->id, ", ") == 0 )
      {
        list->front = item->next->next;
        list->front->prev = NULL;
        free(item->next);
        free(item);
        list->count -= 2;
      }
      else
      {
        printf ("\nError:  Missing , in the attribute list.");
        exit(1);
      }
    }
    // Else, list contains only 1 item.
    else
    {
      list->back = NULL;
      list->front = NULL;
      free(item);
      list->count--;
    }
  }
  //If item is the last node in the list.
  else if (list->back == item)
  {
    /*
      If the attribute is preceded by a comma, remove the attribute and 
      the comma.
    */
    if (strcmp(item->prev->id, ", ") == 0 )
    {
      list->back = item->prev->prev;
      list->back->next = NULL;
      free(item->prev);
      free(item);
      list->count -= 2;
    }
    else
    {
      printf ("\nError:  Missing , in the attribute list.");
      exit(1);
    }
  }
  //Else, item is a middle node in the list.
  else
  {
    /*
      If a comma follows the attribute, remove that attribute and 
      the comma.
    */
    if (strcmp(item->next->id, ", ") == 0 )
    {
      item->prev->next = item->next->next;
      item->next->next->prev = item->prev;
      free(item->next);
      free(item);
      list->count -= 2;
    }
    else
    {
      printf ("\nError:  Missing , in the attribute list.");
      exit(1);
    }
  }
}



/*----------------------------------------------------------------------------
Function name:
  add_outerjoin_stmt 
Purpose:
  To genete the sql statement for leftouterjoin, rightouterjoin and
  fullouterjoin.

Parameters: 
  nselect           The structure containing table, attributes and conditions
                    information.
  binary_op         The binary operator used for the njoin. Its value can be 
                    nleftjoin, nrightjoin, or nfulljoin.

Returns:
  None.
------------------------------------------------------------------------------ */
void add_outerjoin_stmt(SELECTSTMT* nselect, char* binary_op)
{
  if(debug_mode) printf("\nIn add_outerjoin_stmt(). ");

  //LIST_ITEM pointer used to iterate through the tables list.
  LIST_ITEM* current = NULL;
  
  /*
    Flag used to indicate whether an error occurred during the outerjoin 
    statement's construction process. 0 signals an error occurred.
  */
  int error_flag = 0;
  
  //Assign to the first list item in the tables list.
  current = nselect->tables->front;

  /*
    Iterate through the tables list, adding the njoin keywords required for
    the respective natural join operation to be done on the tables.
  */
  while(current != NULL)
  {
    /*

    */
    if ((strcmp(binary_op, "NLEFTJOIN") == 0) && (strcmp(current->id, "? ") == 0))
    {
      strcpy(current->id, " natural left outer join ");
      error_flag = 1;
      break;
    }
    else if ((strcmp(binary_op, "NRIGHTJOIN") == 0) && (strcmp(current->id, "? ") == 0))
    {
      strcpy(current->id, " natural right outer join ");
	    error_flag = 1;
	    break;
    }
    else if ((strcmp(binary_op, "NFULLJOIN") == 0) && (strcmp(current->id, "? ") == 0))
    {
	    strcpy(current->id, " natural full outer join ");
	    error_flag = 1;
	    break;
    }
    current = current->next;
  }

  /*
    Set an error if either of the tables do not exist, or if an error 
    occurred.
  */
  if(nselect->tables == NULL || nselect->tables->front == NULL)
  {
    nselect->f_error = 'E';
    strcpy(nselect->errormsg, "No Table specified.");
  }
  else if(nselect->tables->front->next == NULL) 
  {
    nselect->f_error = 'E';
    strcpy(nselect->errormsg, "Only one Table specified.");
  }
  else if(error_flag == 0)
  {
    nselect->f_error = 'E';
    strcpy(nselect->errormsg, "Unknown error in outer join operation!");
  }

  /*
    Free the memory occupied by the conditions list, and ensure that the 
    pointer for that list is set to NULL.
  */
  freelist(nselect->conditions);
  nselect->conditions = NULL;
}    



/*----------------------------------------------------------------------------
Function name: 
  getSymbSetString_agg 
Purpose:
  To get the aggregate symbol with the variable together.

Parameters:
	symbol            The aggregate symbol.
	variable          The variable in the parenthesis following the aggregate 
                    symbol.

Returns:
  A pointer to a newly created statement holding the aggregate symbol with 
  the variable together as a formatted string.
------------------------------------------------------------------------------ */
SELECTSTMT* getSymbSetString_agg(char* symbol, char* variable)
{
  if(debug_mode) printf("\nIn getSymbSetString_agg(). ");

  /*
    Pointer to temporary array used to hold the formatted string containing 
    an aggregate operation and the variable for which it applies.
  */
  char* temp_str = NULL;
  
  /*
    Pointer used to point to a newly created statement for the purposes of 
    returning a formatted string containing the aggregate operation and the
    variable for which it applies.
  */
  SELECTSTMT* nselect = NULL;
  
  //Array used to temporarily hold the value of the variable.
  char the_variable[MAXLENGTH];

  //Allocate memory for the new statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Change the characters in the symbol string to uppercase.
  uppercase(symbol);

  //Copy the variable string to the temporary array.
  strncpy(the_variable, variable, MAXLENGTH);

  // Allocate memory to the structure to hold the formatted string.
  if ((temp_str = calloc(MAXLENGTH, sizeof(char))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  if(debug_mode) printf("\n In getSymbSetString_agg():, str1:%s, str2:%s ", the_variable, variable);

  //Create the formatted string.
  strncpy(temp_str, symbol, MAXLENGTH);
  strcat(temp_str, "(");
  strcat(temp_str, the_variable);
  strcat(temp_str, ")");
  
  //Add the formatted string to the new statement.
  strcat(nselect->info, temp_str);

  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  aggregatestmt 
Purpose:
  To translate a relational algebra aggregate statement into its 
  corresponding select statement.

Parameters:
	newattributes	    The attributes in the aggregate statement.
	subexpr           The subexpression of the aggregate statement.

Returns:
	Pointer to the structure containing the new select statement.
------------------------------------------------------------------------------ */
SELECTSTMT* aggregatestmt(SELECTSTMT* newattributes, SELECTSTMT* subexpr)
{
  if(debug_mode) printf("\nIn aggregateStmt(). ");
  
  //New select statement that will contain the new aggregate statement.
  SELECTSTMT* nselect = NULL;
  
  /*
    LIST_ITEM pointer used to iterate through the new attribute statement's
    attribute list.
  */
  LIST_ITEM * current = NULL;
  
  /*
    LIST_ITEM pointer used to iterate through the subexpr's attribute list.
  */
  LIST_ITEM * inner_current = NULL;
  
  /*
    Flag used to indicate whether the current attribute was found in the 
    existing statement (subexpr).
  */
  int found = 0; 
  
  /*
    Array used to store the parsed value of the current attribute's id.
  */
  char temp_str[MAXLENGTH];
  
  /*
    Array used to store the value of the current list item's id.
  */
  char tempChar1[MAXLENGTH];
  
  //Array used to construct a string value for the current list item.
  char tempChar2[MAXLENGTH];
  
  //Pointer to the token preceding the open bracket.
  char* tok1 = NULL;
  
  //Pointer to the token following the open bracket.
  char* tok2 = NULL;

  //Allocate memory to new select statement structure.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  // Only translate the statement if the subexpression does not containan error.
  if (subexpr->f_error != 'E')
  {
    //Testing block
    /*
          LIST_ITEM  *tmp_item = NULL;
          tmp_item = newattributes->attributes->front;
          while (tmp_item != NULL)
          {
            printf("\n In aggregatestmt():, tmp_item->id is : %s ", tmp_item->id);
            tmp_item = tmp_item->next;
          }
          printf("\n\n");
    */
 
    /* 
      Set the conditions and tables of the new select statement
      to those of the subexpression.
    */
    nselect->conditions = subexpr->conditions;
    nselect->tables = subexpr->tables;
               
    /* 
      Add the table name to the front of the new attributes in the
      project statement.
    */
    if (subexpr->tables->front->next == NULL)
    {
      if(debug_mode) printf("\n\nIn aggregatestmt():subexpr->tables->front->next == NULL. ");
      nselect->f_error = addtablename_agg(subexpr->tables->front->id, newattributes->attributes->front, nselect->errormsg);
    }
    else
    { 
      nselect->f_error = addptablename_agg(newattributes->attributes->front, subexpr->attributes->front, nselect->errormsg);
    }

    /*
      If the new attributes are not in the subexpression raise an error, and
      free the memory used by the temporary structures.
    */
    if (nselect->f_error == 'E')
    {
      freeexpr(subexpr);
      freelist(newattributes->attributes);
      nselect->conditions = NULL;
      nselect->tables = NULL;

      strcat(nselect->errormsg, " specified in aggregate statement.");
    }
    else
    {
      /*
        Set the attributes of the new select statement to the ones specified 
        in the project statement.
      */
      nselect->attributes = newattributes->attributes;
      
      //Set the pointer to the first element of the attributes list.
      current = newattributes->attributes->front;
      uppercase(current->id);

      /*
        Iterate through the attribute list, and allocate memory for a groupby structure
        if such a structure is necessary for the current statement.
      */
      while(current != NULL)
      {
        if((strstr(current->id, "COUNT(") == NULL) && ( !find_symbol(current->id)) && 
	        (strstr(current->id, ",") == NULL) &&
          (current->type == 'I'))
        {
          //Allocate memory to new LIST statement structure.
          if ((nselect->groupby = (LIST*) calloc(1, sizeof(LIST))) == NULL)
          {
            fprintf(stderr, "Not enough memory to allocate to list!");
            exit(1);
          }

          //Allocate memory to new LIST_ITEM statement structure.
          if ((nselect->groupby->front = (LIST_ITEM*) calloc(1, sizeof(LIST_ITEM))) == NULL)
          {
            fprintf(stderr, "Not enough memory to allocate to list_item!");
            exit(1);
          }

          //If an allocation was made successfully, exit loop.
          if(nselect->groupby != NULL && nselect->groupby->front != NULL){
            strncpy(nselect->groupby->front->id, current->id, MAXLENGTH);
            nselect->groupby->front->type = 'I';
            break;
          }
        }
        current = current->next;
      }
    }
  }
  else
  {
    /*
      If the subexpression contained an error pass this on to the new select 
      statement structure instead of translating the statement.
    */
    strncpy(nselect->errormsg, subexpr->errormsg, MAXERRMSGLENGTH);
    nselect->f_error = subexpr->f_error;
    nselect->tables = subexpr->tables;
  }

  //Return pointer to newly constructed statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  addtablename_agg 
Purpose:
  To add tablename to the front of the attributes in the list from an 
  aggregate statement pointed to by the 'front' pointer.

Parameters:
  tablename	        The tablename to add to the front of attributes.
	front		          The front of the list of attributes.
  errormsg	        The string into which error messages should be stored.

Returns:
  Error char equal to E if the attribute is not in tablename or if the new 
  attribute name is already in tablename and equal to C if all attributes 
  are in the table.
------------------------------------------------------------------------------ */
char addtablename_agg(char* tablename, LIST_ITEM* front, char* errormsg)
{
  if(debug_mode) printf("\nIn addtablename_agg(). ");

  //Declare and initialize a LIST_ITEM pointer to point to the front of the list.
	LIST_ITEM* current = front;

  /*
    Integer variable used to store the result of a search of a list for a string.
    In this function, it will be used to determine if the attribute is already
    present in the list.
  */
  int searchresult;
  
  /*
    Integer variable used as a flag to indicate if the current attribute has an
    open bracket.
  */
  int hasBracket = 0;
  
  /*
    Integer variable used as a flag to indicate if the current attribute has an
    asterisk
  */
  int isStar = 0;
	
  //Array used to construct an id containing a table prefix.
  char tabledot[MAXLENGTH];
  
  //Array used to hold the id of an attribute
  char tempChar1[MAXLENGTH];
  
  //Array used to construct an id containing parenthesis.
  char tempChar2[MAXLENGTH];
	
  //Pointer to the token preceding an open bracket.
  char* tok1 = NULL;
  
  //Pointer to the token following the open bracket.
  char* tok2 = NULL;

  /*
    Retrieve the list of table columns of table 'tablename'.
  */
  LIST* table_columns = retrieve_column_names(tablename);
  
  //Make all of the characters in the tablename string lowercase.
  lowercase(tablename);

  //Testing block
  /*
          LIST_ITEM *tmp_item = NULL;
          
          tmp_item = front;
          while (tmp_item != NULL)
          {
            printf("\n In addtablename_agg(): tmp_item->id is : %s , tmp_item->typr is : %c", 
              tmp_item->id, tmp_item->type);
            tmp_item = tmp_item->next;
          }
          printf("\n\n");
  */

	/*
    Loop through the list of attributes adding tablename to
	  the front of the attribute string.
  */
	while (current != NULL)
	{
    if(debug_mode) printf("\n In addtablename_agg1(): current->id is : %s , current->typr is : %c", 
      current->id, current->type);
		
    //Make all of the characters in the current attribute's id string uppercase.
    uppercase(current->id);

    //If the current attribute list item is an element.
		if ((current->type == 'I') || (current->type == 'N'))
		{
      //If the current attribute list item is an aggregate operation.
      if(strstr(current->id, "COUNT(") != NULL || find_symbol(current->id))
      {
        //Split into tokens.
        strncpy(tempChar1, current->id, MAXLENGTH);
        tok1 = strtok( tempChar1, "(" );
        tok2 = strtok( NULL, ")" );
        strncpy(current->id, tok2, MAXLENGTH);
        hasBracket = 1;

        //If in debug mode, print the state of the second token.
        if(debug_mode)
        {
          if(tok2 == NULL)
          {
            if(debug_mode) printf("\n In addtablename_agg(): tok2 is NULL");
          }
          else
          {
            if(debug_mode) printf("\n In addtablename_agg(): tok2 is : %s", tok2);
          }
        }
        
        //If an asterisk is in the second token, flip the flag.
        if(strcmp(tok2, "*") == 0)
        {
          isStar = 1;
        }
      }

      //If no star is present in the current element.
      if(!isStar){
        //Search whether the current element's id is present amongst the table columns.
			  searchresult = searchlist(current->id, table_columns->front);

        if(debug_mode) printf("\n\nIn addtablename(): The searchresult is : \n%d\n", 
          searchresult);

			  /*
          LIST_ITEM *tmp_item = NULL;
          tmp_item = table_columns->front;
          while (tmp_item != NULL)
			    {
            printf("\n In addtablename_agg2(): table->id is : %s , table->type is : %c", 
              tmp_item->id, tmp_item->type);
            tmp_item = tmp_item->next;
          }
          printf("\n\n");
        */			

        //If the attribute is amongst the table columns, add the table prefix.
			  if ((searchresult == 1) && (current->type == 'I'))
        {
			    strncpy(tabledot, tablename, MAXLENGTH);
				  strcat(tabledot, ".");
				  strcat(tabledot, current->id);
				  strncpy(current->id, tabledot, MAXLENGTH);
			  }
        /*
          If name or negation (no original documentation remains as to the 
          original value of N), return error message.
        */
			  else if ((searchresult == 1) && (current->type == 'N'))
			  {
				  strncpy(errormsg, "Column name ", MAXERRMSGLENGTH);
				  strcat(errormsg, current->id);
				  strcat(errormsg, " already exists in table ");
				  strcat(errormsg, tablename);
          freelist(table_columns);
				  return 'E';
			  }
        //If the attribute was not amongst the table columns, return error.
			  else if ((searchresult != 1) && (current->type == 'I'))
        {
				  strncpy(errormsg, "Invalid column name ", MAXERRMSGLENGTH);
				  strncat(errormsg, current->id, MAXLENGTH);
          freelist(table_columns);
				  return 'E';
        }
      }

      //If the current attribute has a bracket within its id, construct the id.
      if (hasBracket)
	    {
			  strncpy(tempChar2, tok1, MAXLENGTH);
			  strcat(tempChar2, "(");
			  strcat(tempChar2, current->id);
			  strcat(tempChar2, ")");
			  strncpy(current->id, tempChar2, MAXLENGTH);
		  }
                    
      if(debug_mode) printf("\n In addtablename_agg()3: current->id is : %s , current->typr is : %c", 
        current->id, current->type);
		}
    //Iterate to next list item.
    current = current->next;
	}

  //Free memory occupying temporary list.
	freelist(table_columns);
  //Return character signifying the original list had attributes all in common with the original table.
	return 'C';
}



/*----------------------------------------------------------------------------
Function name:
  addptablename_agg 
Purpose:
  To add the tablename to the front of an attribute that is found in the 
  attributes of a subexpression.

Parameters:
  nfront            The front of the list of new attributes to which we 
                    would like to add table names.
  ofront            The front of the list of attributes in the subexpression.
  errormsg          The string to into which error messages should be 
                    inserted.

Returns:
  Error char equal to E if the attribute is not in subexpression or if the 
  new attribute name is already in subexpression and equal to C if all 
  attributes are in the subexpression.
------------------------------------------------------------------------------ */
char addptablename_agg(LIST_ITEM* nfront, LIST_ITEM* ofront, char* errormsg)
{
  if(debug_mode) printf("\nIn addptablename_agg(). ");
  
  //Pointer used to iterate through the main list.
  LIST_ITEM* ncurrent = nfront;
  
  //Pointer used to iterate through the subexpression.
  LIST_ITEM* ocurrent = ofront;

  //Integer flag to indicate whether a bracket was found.
  int hasBracket = 0;
  
  //Integer flag to indicate whether the attribute between parathesis
  //was an asterisk.
  int isStar = 0;

  //Character array used to temporarily hold strings.
  char tempChar1[MAXLENGTH];
  
  //Character array used to temporarily hold strings.
  char tempChar2[MAXLENGTH];
  
  //Pointer used to hold token values.
  char* tok1 = NULL;
  
  //Pointer used to hold token values.
  char* tok2 = NULL;
  
  /*
    Loop through the list of attributes adding the tablename to
    the front of the attribute string.
  */
  while (ncurrent != NULL)
  {
    if(debug_mode) printf("\nIn addptablename_agg() - Checkpoint 1. ");

    uppercase(ncurrent->id);
    
    //If current list item is an attribute or variable.
    if ((ncurrent->type == 'I') || (ncurrent->type == 'N'))
    {
      //If COUNT( is present in the current list item.
      if(strstr(ncurrent->id, "COUNT(") != NULL || find_symbol(ncurrent->id))
      {
        //Copy value of the current list item into tempChar1.
        strncpy(tempChar1, ncurrent->id, MAXLENGTH);

        //Split tempChar1 into tokens based on "(" and assign first token to tok1.
        tok1 = strtok( tempChar1, "(" );

        //Split remaining tokens based on ")" and assign first token to tok2.
        tok2 = strtok( NULL, ")" );

        //Assign value of tok2 to current list item.
        strncpy(ncurrent->id, tok2, MAXLENGTH);

        //Flip flag.
        hasBracket = 1;

        //If a second token could not be found.
        if(tok2 == NULL)
        {
          if(debug_mode) printf("\n In addptablename_agg(): tok2 is NULL");
        }
        else
        {
          if(debug_mode) printf("\n In addptablename_agg(): tok2 is : %s. ", tok2);
          
          // If an asterisk is in the second token.
          if(strcmp(tok2, "*") == 0)
          {
            isStar = 1;
          }
        }
      }

      //If an asterisk was not found within the current list item.
      if(!isStar)
      {
        /*
          Loop through the subexpression until the main list's current item
          is found within the current item of the subexpression. 
        */
        while ((ocurrent != NULL) && (strstr(ocurrent->id, ncurrent->id) == NULL))
        {
          ocurrent = ocurrent->next;
        }
        //If a match was made, and the main list's current item is an attribute.
        if ((ocurrent != NULL) && (ncurrent->type == 'I'))
        {
          strncpy(ncurrent->id, ocurrent->id, MAXLENGTH);
        }
        //If a match was made, and the main list's current item is a variable.
        else if ((ocurrent != NULL) && (ncurrent->type == 'N'))
        {
          strncpy(errormsg, "In addptablename()--Column name ", MAXERRMSGLENGTH);
          strcat(errormsg, ncurrent->id);
          strcat(errormsg, "already exists in subexpression ");
          return 'E';
        }
        //If a match was not made.
        else if ((ocurrent == NULL) && (ncurrent->type == 'I'))
        {
          strncpy(errormsg, "In addptablename()--Invalid column name ", MAXERRMSGLENGTH);
          strcat(errormsg, ncurrent->id);
          return 'E';
        }
      }

      //If an opening bracket was found.
      if(hasBracket)
      {
        strncpy(tempChar2, tok1, MAXLENGTH);
        strcat(tempChar2, "(");
        strcat(tempChar2, ncurrent->id);
        strcat(tempChar2, ")");
        strncpy(ncurrent->id, tempChar2, MAXLENGTH);
      }
      
      //Iterate to next subexpression item.
      ocurrent = ofront;
    }
    
    if(debug_mode) printf("\n In addptablename_agg()3: ncurrent->id is : %s , current->typr is : %c. ", ncurrent->id, ncurrent->type);

    //Iterate to next main list item.
    ncurrent = ncurrent->next;
  }

  //Return status indicating all of the main lists items are in the subexpression.
  return 'C';
}



/*----------------------------------------------------------------------------
Function name:
  find_symbol 
Purpose:
  To find the symbol syntax: "MAX(", "MIN(", "AVG(", "SUM(" from the passed 
  string.

Parameters:
  string            The string which will be parsed for aggregate operation 
                    symbols.

Returns:
  1       If symbol is found.
  0       If symbol is not found.
------------------------------------------------------------------------------ */
int find_symbol(char* string)
{
  if(debug_mode) printf("\nIn find_symbol(). ");

  //Integer variable used to hold the return value of the function
  //indicating whether or not an aggregate operation symbol was found.
  int ret_val = 0;

  //If any of the aggregate operation symbols are found, change the
  //value of ret_val to reflect that discovery.
  if ((strstr(string, "MAX(") != NULL) || 
      (strstr(string, "MIN(") != NULL) ||
      (strstr(string, "AVG(") != NULL) ||
      (strstr(string, "SUM(") != NULL))
  {
    ret_val = 1;
  }

  //Return flag.
  return ret_val;
}



/*----------------------------------------------------------------------------
Function name:
  addorderbylist 
Purpose:
  To add an attribute or symbolSet to a list of orderby and return a 
  structure containing this list.

Parameters:
  symbolSet         The attribute or symbolSet to add to the list.
  invalidchar       The invalidchar (see alg.l for list) to add to the list.
  orderbyvariables  The sublist of attributes or symbolSet for the orderby 
                    portion of the statement.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* addorderbylist(char* symbolSet, char* invalidchar, SELECTSTMT* orderbyvariables)
{
  if(debug_mode) printf("\nIn addorderbylist(): symbolSet: %s. ", symbolSet);

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //If the original orderbyvariables and the invalidchar are not null, add them 
  //to the new statement's orderby list.
  if ((orderbyvariables != NULL) && (invalidchar != NULL))
  {
    nselect->orderby = addtolist(" ", orderbyvariables->orderby, 'E');
    nselect->orderby = addtolist(invalidchar, nselect->orderby, 'E');
    nselect->orderby = addtolist(" ", nselect->orderby, 'E');
  }

  //Add attribute or symbolset to new statement's orderby list.
  nselect->orderby = addtolist(symbolSet, nselect->orderby, 'I');

  //Free memory of the old expression.
  freeexpr(orderbyvariables);

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  addhavinglist 
Purpose:
  To add an attribute or symbolSet to a list of having and return a 
  structure containing this list.

Parameters:
  symbolSet         The attribute or symbolSet to add to the list.
  invalidchar       The invalidchar (see alg.l for list) to add to the list.
  havingvariables   The sublist of attributes or symbolSet for the having
                    portion of the statement.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* addhavinglist(char* symbolSet, char* invalidchar, SELECTSTMT* havingvariables)
{
  if(debug_mode) printf("\nIn addhavinglist(): symbolSet: %s. ", symbolSet);

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Attempt to allocate memory for the having list in the new statement.
  if ((nselect->having = (LIST*) calloc(1, sizeof(LIST))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //If the original havingvariables and the having sublist are not null, add to the
  //new statement's having list.
  if((havingvariables != NULL) && (havingvariables->having != NULL) && (invalidchar != NULL))
  {
    nselect->having = havingvariables->having;
    nselect->having = addtolist(" ", nselect->having, 'E');
    nselect->having = addtolist(invalidchar, nselect->having, 'E');
    nselect->having = addtolist(" ", nselect->having, 'E');
  }

  //Add attribute or symbolset to new statement's having list.
  nselect->having = addtolist(symbolSet, nselect->having, 'I');

  //Free memory of the old expression.
  freeexpr(havingvariables);

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  orderbystmt 
Purpose:
  To add ascending or descending to a list of orderby and return a structure 
  containing this list.

Parameters:
  orderbyvariables  The sublist of attributes or symbolSet containing 
                    variables in the orderby portion of the existing 
                    statement.
  ascdesc           The string to be added to the list.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* orderbystmt(SELECTSTMT* orderbyvariables, char* ascdesc)
{
  if(debug_mode) printf("\nIn orderbystmt(). ");
  
  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;
  char empty[] = " ";

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Add orderby expression to the back of orderby portion of the new statement.
  nselect->orderby = addtoback(empty, orderbyvariables->orderby, 'E');
  nselect->orderby = addtoback(ascdesc, nselect->orderby, 'E');
  
  //Free memory of the old expression.
  freeexpr(orderbyvariables);
  
  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  havingstmt 
Purpose:
  To add an RELOP and CONSTANT to a list of having and return a structure 
  containing this list.

Parameters:
  havingvariables   The sublist of attributes or symbolSet containing 
                    variables in the having portion of the existing 
                    statement.
  relop             The Relative Operator to add to the list.
  constant          The constant to add to the list.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* havingstmt(SELECTSTMT* havingvariables, char* relop, char* constant)
{
  if(debug_mode) printf("\nIn havingstmt(). ");

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;
  char empty[] = " ";

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Add having expression to the back of having portion of the new statement.
  nselect->having = addtoback(empty, havingvariables->having, 'E');
  nselect->having = addtoback(relop, nselect->having, 'E');
  nselect->having = addtoback(empty, nselect->having, 'E');
  nselect->having = addtoback(constant, nselect->having, 'E');
  
  //Remnant from when the expression was a temporary saved statement.
  /*freeexpr(havingvariables);*/

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  orderbyhavingstmt 
Purpose:
  To add an RELOP and CONSTANT to a list of having and return a structure 
  containing this list.

Parameters:
  expression        The sublist of attributes or symbolSet for the 
                    expression portion of the havings statement.
  orderbystru       The sublist of attributes or symbolSet of an orderby 
                    portion of the statement if it exists.
  havingstru        The sublist of attributes or symbolSet for the having 
                    portion of the statement.

Returns:
  Pointer to the structure containing the havings and orderby potions
  of a statement.
------------------------------------------------------------------------------ */
SELECTSTMT* orderbyhavingstmt(SELECTSTMT* expression, SELECTSTMT* orderbystru, SELECTSTMT* havingstru)
{
  if(debug_mode) printf("\nIn orderbyhavingstmt(). ");

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //Add the table names to the front of the attributes of orderby list in the orderbystru if it exists.
  if(orderbystru != NULL){
    if (expression->tables->front->next == NULL)
    {
      if(debug_mode) printf("\n\nIn orderbyhavingstmt(): orderbystruct!=NULL, expression->tables->front->next == NULL. ");
      
      //Complete operation and obtain error status.
      nselect->f_error = addtablename_agg(expression->tables->front->id, orderbystru->orderby->front, nselect->errormsg);
    }
    else
    {
      if(debug_mode) printf("\n\nIn orderbyhavingstmt(): orderbystruct!=NULL, expression->tables->front->next != NULL. ");

      //Complete operation and obtain error status.
      nselect->f_error = addptablename_agg(orderbystru->orderby->front, expression->attributes->front, nselect->errormsg);
    }

    //If adding the table name to the attribute list failed.
    if (nselect->f_error == 'E')
    {
      //If the attributes in the new orderbystru are not in the expression raise an error,
      //and free the memory occupied by the expression and orderby structure.
      freeexpr(expression);
      freelist(orderbystru->orderby);

      //Append location of error to error message.
      strcat(nselect->errormsg, " specified in orderby statement.");
    }
    else
    {
      //Assign current status of the orderby structure to the new statement's orderby portion.
      if(orderbystru->orderby!= NULL)
      {
        nselect->orderby = orderbystru->orderby;
      } 
    }
  }

  //Add the table names to the front of the attributes of having list in the havingstru structure.
  if(havingstru != NULL){
    if (expression->tables->front->next == NULL)
    {
      if(debug_mode) printf("\n\nIn orderbyhavingstmt(): havingstru!=NULL, expression->tables->front->next == NULL. ");

      //Complete operation and obtain error status.
      nselect->f_error = addtablename_agg(expression->tables->front->id, havingstru->having->front, nselect->errormsg);
    }
    else
    {
      if(debug_mode) printf("\n\nIn orderbyhavingstmt(): havingstru!=NULL, expression->tables->front->next != NULL. ");
      
      //Complete operation and obtain error status.
      nselect->f_error = addptablename_agg(havingstru->having->front, expression->attributes->front, nselect->errormsg);
    }

    //If adding the table name to the attribute list failed.
    if (nselect->f_error == 'E')
    {
      //If the attributes in the new orderbystru are not in the expression raise an error.
      if(expression != NULL) 
      {
        freeexpr(expression);
      }
      freelist(havingstru->having);
      
      //Append location of error to error message.
      strcat(nselect->errormsg, " specified in having statement.");
    }
    else
    {
      //Assign current status of the having structure to the new statement's having portion.
      if(havingstru->having != NULL)
      {
        nselect->having = havingstru->having;
      }
    }
  }

  //Copy over the state of the expression to the new statement.
  nselect->tables = expression->tables;
  nselect->attributes = expression->attributes;
  nselect->groupby = expression->groupby;
  nselect->conditions = expression->conditions;

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  operand_list_agg 
Purpose:
  To add an operand and an operator to a list and return a structure 
  containing this list.

Parameters:
  operand           The operand to add to the list.
  operator          The operator to add to the list.
  operands          Sublist of operands and operators.

Returns:
  Pointer to the structure containing the list of operands.
------------------------------------------------------------------------------ */
SELECTSTMT* operand_list_agg(char* operand, char* operator, SELECTSTMT* operands)
{
  if(debug_mode) printf("\nIn operand_list_agg(). ");

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;
  
  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "operand_list_agg: Not enough memory to allocate to list!");
    exit(1);
  }
  
  //Add operator and operands to attribute list.
  nselect->conditions = addtolist(" ", operands->conditions, 'E'); 
  nselect->conditions = addtolist(operator, nselect->conditions, 'E');
  nselect->conditions = addtolist(" ", nselect->conditions, 'E');
  nselect->conditions = addtolist(operand, nselect->conditions, 'I');

  //Testing block to test state of conditions:
  /*
    LIST_ITEM* tmp_item = NULL;
    tmp_item = nselect->conditions->front;
    while (tmp_item != NULL)
    {
      printf("\n In operand_list_agg(): tmp_item->id is : %s , tmp_item->typr is : %c. ", tmp_item->id, tmp_item->type);
      tmp_item = tmp_item->next;
    }
    printf("\n\n");
  */

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:
  attribute_list_asop 
Purpose:
  To add two attributes, an 'as' or an operator to a list of attributes and 
  return a structure containing this list.

Parameters:
  variable1         The attribute to add to the list.
  as_op             The 'as' or the operator to add to the list.
  variable2         The attribute to add to the list.
  sublist           The sublist of attributes.

Returns:
  Pointer to the structure containing the list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* attribute_list_asop(char* variable1, char* as_op, char* variable2, SELECTSTMT* sublist)
{
  if(debug_mode) printf("\nIn attribute_list_asop(): variables: %s, %s, %s. ", variable1, as_op, variable2);
  
  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //If the sublist is not NULL, add the new attribute list items.
  if (sublist != NULL)
  {
    nselect->attributes = addtolist(", ", sublist->attributes, 'E');
  }

  //Add operator and attribute to attribute list.
  uppercase(as_op); 
  if (strcmp(as_op, "AS") == 0)
  {
    nselect->attributes = addtolist(variable2, nselect->attributes, 'E');
  }
  else
  {
    nselect->attributes = addtolist(variable2, nselect->attributes, 'I');
  }
  nselect->conditions = addtolist(" ", nselect->attributes, 'E');
  nselect->attributes = addtolist(as_op, nselect->attributes, 'E');
  nselect->conditions = addtolist(" ", nselect->attributes, 'E');
  nselect->attributes = addtolist(variable1, nselect->attributes, 'I');

  //Return new statement.
  return nselect;
}



/*----------------------------------------------------------------------------
Function name:      
  attribute_list_aggasop 
Purpose:
  To add two attributes, an 'as' or an operator to a list of attributes
  for an aggregate statement and return a structure containing this list.

Parameters:
  variable1         The attribute to add to the list.
  as_op             The 'as' or the operator to add to the list.
  variable2         The attribute to add to the list.
  sublist           The sublist of attributes.

Returns:
  Pointer to the structure containing the new list of attributes.
------------------------------------------------------------------------------ */
SELECTSTMT* attribute_list_aggasop(char* variable1, char* as_op, char* variable2, SELECTSTMT* sublist)
{
  if(debug_mode) printf("\nIn attribute_list_aggasop(): variables: %s, %s, %s. ", variable1, as_op, variable2);

  //Pointer for new statement.
  SELECTSTMT* nselect = NULL;

  //Attempt to allocate memory for the statement.
  if ((nselect = (SELECTSTMT*) calloc(1, sizeof(SELECTSTMT))) == NULL)
  {
    fprintf(stderr, "Not enough memory to allocate to list!");
    exit(1);
  }

  //If the sublist is not NULL, add the new attribute list items.
  if (sublist != NULL)
  {
    nselect->attributes = addtolist(", ", sublist->attributes, 'E');
  }

  //Add operator and attribute to attribute list.
  uppercase(as_op);
  if (strcmp(as_op, "AS") == 0)
  {
    nselect->attributes = addtolist(variable2, nselect->attributes, 'E');
  }
  else
  {
    nselect->attributes = addtolist(variable2, nselect->attributes, 'I');
  }
  nselect->conditions = addtolist(" ", nselect->attributes, 'E');
  nselect->attributes = addtolist(as_op, nselect->attributes, 'E');
  nselect->conditions = addtolist(" ", nselect->attributes, 'E');
  nselect->attributes = addtolist(variable1, nselect->attributes, 'I');

  //Return new statement.
  return nselect;
}



/* ----------------------- END -------------------------- */
